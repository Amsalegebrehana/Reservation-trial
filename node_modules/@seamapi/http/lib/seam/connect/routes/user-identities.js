/*
 * Automatically generated by generate-routes.ts.
 * Do not edit this file or add other files to this directory.
 */
import { warnOnInsecureuserIdentifierKey } from '../../../../lib/seam/connect/auth.js';
import { createClient } from '../../../../lib/seam/connect/client.js';
import { isSeamHttpOptionsWithApiKey, isSeamHttpOptionsWithClient, isSeamHttpOptionsWithClientSessionToken, isSeamHttpOptionsWithConsoleSessionToken, isSeamHttpOptionsWithPersonalAccessToken, SeamHttpInvalidOptionsError, } from '../../../../lib/seam/connect/options.js';
import { limitToSeamHttpRequestOptions, parseOptions, } from '../../../../lib/seam/connect/parse-options.js';
import { SeamHttpClientSessions } from './client-sessions.js';
import { SeamHttpUserIdentitiesEnrollmentAutomations } from './user-identities-enrollment-automations.js';
export class SeamHttpUserIdentities {
    constructor(apiKeyOrOptions = {}) {
        const options = parseOptions(apiKeyOrOptions);
        this.client = 'client' in options ? options.client : createClient(options);
        this.defaults = limitToSeamHttpRequestOptions(options);
    }
    static fromClient(client, options = {}) {
        const constructorOptions = { ...options, client };
        if (!isSeamHttpOptionsWithClient(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing client');
        }
        return new SeamHttpUserIdentities(constructorOptions);
    }
    static fromApiKey(apiKey, options = {}) {
        const constructorOptions = { ...options, apiKey };
        if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing apiKey');
        }
        return new SeamHttpUserIdentities(constructorOptions);
    }
    static fromClientSessionToken(clientSessionToken, options = {}) {
        const constructorOptions = { ...options, clientSessionToken };
        if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing clientSessionToken');
        }
        return new SeamHttpUserIdentities(constructorOptions);
    }
    static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
        warnOnInsecureuserIdentifierKey(userIdentifierKey);
        const clientOptions = parseOptions({ ...options, publishableKey });
        if (isSeamHttpOptionsWithClient(clientOptions)) {
            throw new SeamHttpInvalidOptionsError('The client option cannot be used with SeamHttp.fromPublishableKey');
        }
        const client = createClient(clientOptions);
        const clientSessions = SeamHttpClientSessions.fromClient(client);
        const { token } = await clientSessions.getOrCreate({
            user_identifier_key: userIdentifierKey,
        });
        return SeamHttpUserIdentities.fromClientSessionToken(token, options);
    }
    static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
        const constructorOptions = { ...options, consoleSessionToken, workspaceId };
        if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing consoleSessionToken or workspaceId');
        }
        return new SeamHttpUserIdentities(constructorOptions);
    }
    static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
        const constructorOptions = { ...options, personalAccessToken, workspaceId };
        if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
            throw new SeamHttpInvalidOptionsError('Missing personalAccessToken or workspaceId');
        }
        return new SeamHttpUserIdentities(constructorOptions);
    }
    get enrollmentAutomations() {
        return SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(this.client, this.defaults);
    }
    async addAcsUser(body) {
        await this.client.request({
            url: '/user_identities/add_acs_user',
            method: 'post',
            data: body,
        });
    }
    async create(body) {
        const { data } = await this.client.request({
            url: '/user_identities/create',
            method: 'post',
            data: body,
        });
        return data.user_identity;
    }
    async get(body) {
        const { data } = await this.client.request({
            url: '/user_identities/get',
            method: 'post',
            data: body,
        });
        return data.user_identity;
    }
    async grantAccessToDevice(body) {
        await this.client.request({
            url: '/user_identities/grant_access_to_device',
            method: 'post',
            data: body,
        });
    }
    async list(body) {
        const { data } = await this.client.request({
            url: '/user_identities/list',
            method: 'post',
            data: body,
        });
        return data.user_identities;
    }
    async listAccessibleDevices(body) {
        const { data } = await this.client.request({
            url: '/user_identities/list_accessible_devices',
            method: 'post',
            data: body,
        });
        return data.accessible_devices;
    }
    async listAcsSystems(body) {
        const { data } = await this.client.request({
            url: '/user_identities/list_acs_systems',
            method: 'post',
            data: body,
        });
        return data.acs_systems;
    }
    async listAcsUsers(body) {
        const { data } = await this.client.request({
            url: '/user_identities/list_acs_users',
            method: 'post',
            data: body,
        });
        return data.acs_users;
    }
    async removeAcsUser(body) {
        await this.client.request({
            url: '/user_identities/remove_acs_user',
            method: 'post',
            data: body,
        });
    }
    async revokeAccessToDevice(body) {
        await this.client.request({
            url: '/user_identities/revoke_access_to_device',
            method: 'post',
            data: body,
        });
    }
}
//# sourceMappingURL=user-identities.js.map