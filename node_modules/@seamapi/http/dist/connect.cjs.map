{"version":3,"sources":["../src/lib/version.ts","../src/lib/seam/connect/parse-options.ts","../src/lib/seam/connect/options.ts","../src/lib/seam/connect/token.ts","../src/lib/seam/connect/auth.ts","../src/lib/seam/connect/error-interceptor.ts","../src/lib/seam/connect/seam-http-error.ts","../src/lib/seam/connect/client.ts","../src/lib/seam/connect/openapi.ts","../src/lib/seam/connect/resolve-action-attempt.ts","../src/lib/seam/connect/routes/client-sessions.ts","../src/lib/seam/connect/routes/access-codes-unmanaged.ts","../src/lib/seam/connect/routes/access-codes.ts","../src/lib/seam/connect/routes/acs-access-groups.ts","../src/lib/seam/connect/routes/acs-credential-pools.ts","../src/lib/seam/connect/routes/acs-credential-provisioning-automations.ts","../src/lib/seam/connect/routes/acs-credentials.ts","../src/lib/seam/connect/routes/acs-entrances.ts","../src/lib/seam/connect/routes/acs-systems.ts","../src/lib/seam/connect/routes/acs-users.ts","../src/lib/seam/connect/routes/acs.ts","../src/lib/seam/connect/routes/action-attempts.ts","../src/lib/seam/connect/routes/connect-webviews.ts","../src/lib/seam/connect/routes/connected-accounts.ts","../src/lib/seam/connect/routes/devices-unmanaged.ts","../src/lib/seam/connect/routes/devices.ts","../src/lib/seam/connect/routes/events.ts","../src/lib/seam/connect/routes/locks.ts","../src/lib/seam/connect/routes/networks.ts","../src/lib/seam/connect/routes/noise-sensors-noise-thresholds.ts","../src/lib/seam/connect/routes/noise-sensors.ts","../src/lib/seam/connect/routes/phones.ts","../src/lib/seam/connect/routes/thermostats-climate-setting-schedules.ts","../src/lib/seam/connect/routes/thermostats.ts","../src/lib/seam/connect/routes/user-identities-enrollment-automations.ts","../src/lib/seam/connect/routes/user-identities.ts","../src/lib/seam/connect/routes/webhooks.ts","../src/lib/seam/connect/routes/workspaces.ts","../src/lib/seam/connect/seam-http.ts","../src/lib/seam/connect/seam-http-multi-workspace.ts","../src/connect.ts"],"names":[],"mappings":"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","sourcesContent":["const seamapiJavascriptHttpVersion = null\n\nexport default seamapiJavascriptHttpVersion\n","import version from 'lib/version.js'\n\nimport { getAuthHeaders } from './auth.js'\nimport type { Client, ClientOptions } from './client.js'\nimport {\n  isSeamHttpMultiWorkspaceOptionsWithClient,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  type SeamHttpMultiWorkspaceOptions,\n  type SeamHttpOptions,\n  type SeamHttpRequestOptions,\n} from './options.js'\n\nexport const defaultEndpoint = 'https://connect.getseam.com'\n\nexport const sdkHeaders = {\n  'seam-sdk-name': 'seamapi/javascript-http',\n  'seam-sdk-version': version,\n}\n\nexport type Options =\n  | SeamHttpMultiWorkspaceOptions\n  | (SeamHttpOptions & { publishableKey?: string })\n\ntype ParsedOptions = Required<\n  (ClientOptions | { client: Client }) & SeamHttpRequestOptions\n>\n\nexport const parseOptions = (\n  apiKeyOrOptions: string | Options,\n): ParsedOptions => {\n  const options = getNormalizedOptions(apiKeyOrOptions)\n\n  if (isSeamHttpOptionsWithClient(options)) return options\n  if (isSeamHttpMultiWorkspaceOptionsWithClient(options)) return options\n\n  return {\n    ...options,\n    axiosOptions: {\n      baseURL: options.endpoint ?? getEndpointFromEnv() ?? defaultEndpoint,\n      withCredentials: isSeamHttpOptionsWithClientSessionToken(options),\n      ...options.axiosOptions,\n      headers: {\n        ...getAuthHeaders(options),\n        ...options.axiosOptions?.headers,\n        ...sdkHeaders,\n      },\n    },\n    axiosRetryOptions: {\n      ...options.axiosRetryOptions,\n    },\n  }\n}\n\nconst getNormalizedOptions = (\n  apiKeyOrOptions: string | Options,\n): SeamHttpOptions & Required<SeamHttpRequestOptions> => {\n  const options =\n    typeof apiKeyOrOptions === 'string'\n      ? { apiKey: apiKeyOrOptions }\n      : apiKeyOrOptions\n\n  const requestOptions = {\n    waitForActionAttempt: options.waitForActionAttempt ?? false,\n  }\n\n  if (isSeamHttpOptionsWithClient(options)) {\n    return {\n      ...options,\n      ...requestOptions,\n    }\n  }\n\n  const apiKey =\n    'apiKey' in options ? options.apiKey : getApiKeyFromEnv(options)\n\n  return {\n    ...options,\n    ...(apiKey != null ? { apiKey } : {}),\n    ...requestOptions,\n  }\n}\n\nconst getApiKeyFromEnv = (\n  options: SeamHttpOptions,\n): string | null | undefined => {\n  if ('clientSessionToken' in options && options.clientSessionToken != null) {\n    return null\n  }\n  if ('consoleSessionToken' in options && options.consoleSessionToken != null) {\n    return null\n  }\n  if ('personalAccessToken' in options && options.personalAccessToken != null) {\n    return null\n  }\n  return globalThis.process?.env?.SEAM_API_KEY\n}\n\nconst getEndpointFromEnv = (): string | null | undefined => {\n  if (globalThis.process?.env?.SEAM_API_URL != null) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Using the SEAM_API_URL environment variable is deprecated. Support will be remove in a later major version. Use SEAM_ENDPOINT instead.',\n    )\n  }\n\n  if (\n    globalThis.process?.env?.SEAM_API_URL != null &&\n    globalThis.process?.env?.SEAM_ENDPOINT != null\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Detected both the SEAM_API_URL and SEAM_ENDPOINT environment variables. Using SEAM_ENDPOINT.',\n    )\n  }\n\n  return (\n    globalThis.process?.env?.SEAM_ENDPOINT ??\n    globalThis.process?.env?.SEAM_API_URL\n  )\n}\n\nexport const limitToSeamHttpRequestOptions = (\n  options: Required<SeamHttpRequestOptions>,\n): Required<SeamHttpRequestOptions> => {\n  return Object.keys(options)\n    .filter(isSeamHttpRequestOption)\n    .reduce(\n      (obj, key) => ({\n        ...obj,\n        [key]: options[key],\n      }),\n      {},\n    ) as Required<SeamHttpRequestOptions>\n}\n\nexport const isSeamHttpRequestOption = (\n  key: string,\n): key is keyof SeamHttpRequestOptions => {\n  const keys: Record<keyof SeamHttpRequestOptions, true> = {\n    waitForActionAttempt: true,\n  }\n  return Object.keys(keys).includes(key)\n}\n","import type { Client, ClientOptions } from './client.js'\nimport { isSeamHttpRequestOption } from './parse-options.js'\nimport type { ResolveActionAttemptOptions } from './resolve-action-attempt.js'\n\nexport type SeamHttpMultiWorkspaceOptions =\n  | SeamHttpMultiWorkspaceOptionsWithClient\n  | SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken\n  | SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken\n\nexport type SeamHttpOptions =\n  | SeamHttpOptionsFromEnv\n  | SeamHttpOptionsWithClient\n  | SeamHttpOptionsWithApiKey\n  | SeamHttpOptionsWithClientSessionToken\n  | SeamHttpOptionsWithConsoleSessionToken\n  | SeamHttpOptionsWithPersonalAccessToken\n\ninterface SeamHttpCommonOptions extends ClientOptions, SeamHttpRequestOptions {\n  endpoint?: string\n}\n\nexport interface SeamHttpRequestOptions {\n  waitForActionAttempt?: boolean | ResolveActionAttemptOptions\n}\n\nexport interface SeamHttpFromPublishableKeyOptions\n  extends SeamHttpCommonOptions {}\n\nexport interface SeamHttpOptionsFromEnv extends SeamHttpCommonOptions {}\n\nexport interface SeamHttpMultiWorkspaceOptionsWithClient\n  extends SeamHttpRequestOptions {\n  client: Client\n}\n\nexport const isSeamHttpMultiWorkspaceOptionsWithClient = (\n  options: SeamHttpOptions,\n): options is SeamHttpMultiWorkspaceOptionsWithClient =>\n  isSeamHttpOptionsWithClient(options)\n\nexport interface SeamHttpOptionsWithClient extends SeamHttpRequestOptions {\n  client: Client\n}\n\nexport const isSeamHttpOptionsWithClient = (\n  options: SeamHttpOptions,\n): options is SeamHttpOptionsWithClient => {\n  if (!('client' in options)) return false\n  if (options.client == null) return false\n\n  const keys = Object.keys(options).filter((k) => k !== 'client')\n  if (keys.filter((k) => !isSeamHttpRequestOption(k)).length > 0) {\n    throw new SeamHttpInvalidOptionsError(\n      `The client option cannot be used with any other option, but received: ${keys.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpOptionsWithApiKey extends SeamHttpCommonOptions {\n  apiKey: string\n}\n\nexport const isSeamHttpOptionsWithApiKey = (\n  options: SeamHttpOptions,\n): options is SeamHttpOptionsWithApiKey => {\n  if (!('apiKey' in options)) return false\n  if (options.apiKey == null) return false\n\n  if ('clientSessionToken' in options && options.clientSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The clientSessionToken option cannot be used with the apiKey option',\n    )\n  }\n\n  if ('consoleSessionToken' in options && options.consoleSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The consoleSessionToken option cannot be used with the apiKey option',\n    )\n  }\n\n  if ('personalAccessToken' in options && options.personalAccessToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The personalAccessToken option cannot be used with the apiKey option',\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpOptionsWithClientSessionToken\n  extends SeamHttpCommonOptions {\n  clientSessionToken: string\n}\n\nexport const isSeamHttpOptionsWithClientSessionToken = (\n  options: SeamHttpOptions,\n): options is SeamHttpOptionsWithClientSessionToken => {\n  if (!('clientSessionToken' in options)) return false\n  if (options.clientSessionToken == null) return false\n\n  if ('apiKey' in options && options.apiKey != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The apiKey option cannot be used with the clientSessionToken option',\n    )\n  }\n\n  if ('consoleSessionToken' in options && options.consoleSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The consoleSessionToken option cannot be used with the clientSessionToken option',\n    )\n  }\n\n  if ('personalAccessToken' in options && options.personalAccessToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The personalAccessToken option cannot be used with the clientSessionToken option',\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken\n  extends SeamHttpCommonOptions {\n  consoleSessionToken: string\n}\n\nexport const isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken = (\n  options: SeamHttpOptions,\n): options is SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken => {\n  if (!('consoleSessionToken' in options)) return false\n  if (options.consoleSessionToken == null) return false\n\n  if ('apiKey' in options && options.apiKey != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The apiKey option cannot be used with the consoleSessionToken option',\n    )\n  }\n\n  if ('clientSessionToken' in options && options.clientSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The clientSessionToken option cannot be used with the consoleSessionToken option',\n    )\n  }\n\n  if ('personalAccessToken' in options && options.personalAccessToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The personalAccessToken option cannot be used with the consoleSessionToken option',\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpOptionsWithConsoleSessionToken\n  extends SeamHttpCommonOptions {\n  consoleSessionToken: string\n  workspaceId: string\n}\n\nexport const isSeamHttpOptionsWithConsoleSessionToken = (\n  options: SeamHttpOptions,\n): options is SeamHttpOptionsWithConsoleSessionToken => {\n  if (!isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options)) {\n    return false\n  }\n\n  if (!('workspaceId' in options) || options.workspaceId == null) {\n    throw new SeamHttpInvalidOptionsError(\n      'Must pass a workspaceId when using a consoleSessionToken',\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken\n  extends SeamHttpCommonOptions {\n  personalAccessToken: string\n}\n\nexport const isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken = (\n  options: SeamHttpOptions,\n): options is SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken => {\n  if (!('personalAccessToken' in options)) return false\n  if (options.personalAccessToken == null) return false\n\n  if ('apiKey' in options && options.apiKey != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The apiKey option cannot be used with the personalAccessToken option',\n    )\n  }\n\n  if ('clientSessionToken' in options && options.clientSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The clientSessionToken option cannot be used with the personalAccessToken option',\n    )\n  }\n\n  if ('consoleSessionToken' in options && options.consoleSessionToken != null) {\n    throw new SeamHttpInvalidOptionsError(\n      'The consoleSessionToken option cannot be used with the personalAccessToken option',\n    )\n  }\n\n  return true\n}\n\nexport interface SeamHttpOptionsWithPersonalAccessToken\n  extends SeamHttpCommonOptions {\n  personalAccessToken: string\n  workspaceId: string\n}\n\nexport const isSeamHttpOptionsWithPersonalAccessToken = (\n  options: SeamHttpOptions,\n): options is SeamHttpOptionsWithPersonalAccessToken => {\n  if (!isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options)) {\n    return false\n  }\n\n  if (!('workspaceId' in options) || options.workspaceId == null) {\n    throw new SeamHttpInvalidOptionsError(\n      'Must pass a workspaceId when using a personalAccessToken',\n    )\n  }\n\n  return true\n}\n\nexport class SeamHttpInvalidOptionsError extends Error {\n  constructor(message: string) {\n    super(`SeamHttp received invalid options: ${message}`)\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport class SeamHttpMultiWorkspaceInvalidOptionsError extends SeamHttpInvalidOptionsError {}\n","export const tokenPrefix = 'seam_'\n\nexport const accessTokenPrefix = 'seam_at'\n\nexport const jwtPrefix = 'ey'\n\nexport const clientSessionTokenPrefix = 'seam_cst'\n\nexport const publishableKeyTokenPrefix = 'seam_pk'\n\nexport const isAccessToken = (token: string): boolean =>\n  token.startsWith(accessTokenPrefix)\n\nexport const isJwt = (token: string): boolean => token.startsWith(jwtPrefix)\n\nexport const isSeamToken = (token: string): boolean =>\n  token.startsWith(tokenPrefix)\n\nexport const isApiKey = (token: string): boolean =>\n  !isClientSessionToken(token) &&\n  !isJwt(token) &&\n  !isAccessToken(token) &&\n  !isPublishableKey(token) &&\n  isSeamToken(token)\n\nexport const isClientSessionToken = (token: string): boolean =>\n  token.startsWith(clientSessionTokenPrefix)\n\nexport const isPublishableKey = (token: string): boolean =>\n  token.startsWith(publishableKeyTokenPrefix)\n\nexport const isConsoleSessionToken = (token: string): boolean => isJwt(token)\n\nexport const isPersonalAccessToken = (token: string): boolean =>\n  isAccessToken(token)\n","import {\n  isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken,\n  isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken,\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken,\n  type SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n} from './options.js'\nimport type { Options } from './parse-options.js'\nimport {\n  accessTokenPrefix,\n  clientSessionTokenPrefix,\n  isAccessToken,\n  isClientSessionToken,\n  isJwt,\n  isPublishableKey,\n  isSeamToken,\n  jwtPrefix,\n  publishableKeyTokenPrefix,\n  tokenPrefix,\n} from './token.js'\n\ntype Headers = Record<string, string>\n\nexport const getAuthHeaders = (options: Options): Headers => {\n  if ('publishableKey' in options) {\n    return getAuthHeadersForPublishableKey(options.publishableKey)\n  }\n\n  if (isSeamHttpOptionsWithApiKey(options)) {\n    return getAuthHeadersForApiKey(options)\n  }\n\n  if (isSeamHttpOptionsWithClientSessionToken(options)) {\n    return getAuthHeadersForClientSessionToken(options)\n  }\n\n  if (\n    isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options) ||\n    isSeamHttpOptionsWithConsoleSessionToken(options)\n  ) {\n    return getAuthHeadersForConsoleSessionToken(options)\n  }\n\n  if (\n    isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options) ||\n    isSeamHttpOptionsWithPersonalAccessToken(options)\n  ) {\n    return getAuthHeadersForPersonalAccessToken(options)\n  }\n\n  throw new SeamHttpInvalidOptionsError(\n    [\n      'Must specify',\n      'an apiKey,',\n      'clientSessionToken,',\n      'publishableKey,',\n      'consoleSessionToken',\n      'or personalAccessToken.',\n      'Attempted reading configuration from the environment, but the environment variable SEAM_API_KEY is not set.',\n    ].join(' '),\n  )\n}\n\nconst getAuthHeadersForApiKey = ({\n  apiKey,\n}: SeamHttpOptionsWithApiKey): Headers => {\n  if (isClientSessionToken(apiKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Client Session Token cannot be used as an apiKey',\n    )\n  }\n\n  if (isJwt(apiKey)) {\n    throw new SeamHttpInvalidTokenError('A JWT cannot be used as an apiKey')\n  }\n\n  if (isAccessToken(apiKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'An Access Token cannot be used as an apiKey',\n    )\n  }\n\n  if (isPublishableKey(apiKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Publishable Key cannot be used as an apiKey',\n    )\n  }\n\n  if (!isSeamToken(apiKey)) {\n    throw new SeamHttpInvalidTokenError(\n      `Unknown or invalid apiKey format, expected token to start with ${tokenPrefix}`,\n    )\n  }\n\n  return {\n    authorization: `Bearer ${apiKey}`,\n  }\n}\n\nconst getAuthHeadersForClientSessionToken = ({\n  clientSessionToken,\n}: SeamHttpOptionsWithClientSessionToken): Headers => {\n  if (isJwt(clientSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A JWT cannot be used as a clientSessionToken',\n    )\n  }\n\n  if (isAccessToken(clientSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'An Access Token cannot be used as a clientSessionToken',\n    )\n  }\n\n  if (isPublishableKey(clientSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Publishable Key cannot be used as a clientSessionToken',\n    )\n  }\n\n  if (!isClientSessionToken(clientSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      `Unknown or invalid clientSessionToken format, expected token to start with ${clientSessionTokenPrefix}`,\n    )\n  }\n\n  return {\n    authorization: `Bearer ${clientSessionToken}`,\n    'client-session-token': clientSessionToken,\n  }\n}\n\nconst getAuthHeadersForConsoleSessionToken = ({\n  consoleSessionToken,\n  ...options\n}:\n  | SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken\n  | SeamHttpOptionsWithConsoleSessionToken): Headers => {\n  const workspaceId = 'workspaceId' in options ? options.workspaceId : undefined\n\n  if (isAccessToken(consoleSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'An Access Token cannot be used as a consoleSessionToken',\n    )\n  }\n\n  if (isClientSessionToken(consoleSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Client Session Token cannot be used as a consoleSessionToken',\n    )\n  }\n\n  if (isPublishableKey(consoleSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Publishable Key cannot be used as a consoleSessionToken',\n    )\n  }\n\n  if (!isJwt(consoleSessionToken)) {\n    throw new SeamHttpInvalidTokenError(\n      `Unknown or invalid consoleSessionToken format, expected a JWT which starts with ${jwtPrefix}`,\n    )\n  }\n\n  return {\n    authorization: `Bearer ${consoleSessionToken}`,\n    ...(workspaceId != null ? { 'seam-workspace': workspaceId } : {}),\n  }\n}\n\nconst getAuthHeadersForPersonalAccessToken = ({\n  personalAccessToken,\n  ...options\n}:\n  | SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken\n  | SeamHttpOptionsWithPersonalAccessToken): Headers => {\n  const workspaceId = 'workspaceId' in options ? options.workspaceId : undefined\n\n  if (isJwt(personalAccessToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A JWT cannot be used as a personalAccessToken',\n    )\n  }\n\n  if (isClientSessionToken(personalAccessToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Client Session Token cannot be used as a personalAccessToken',\n    )\n  }\n\n  if (isPublishableKey(personalAccessToken)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Publishable Key cannot be used as a personalAccessToken',\n    )\n  }\n\n  if (!isAccessToken(personalAccessToken)) {\n    throw new SeamHttpInvalidTokenError(\n      `Unknown or invalid personalAccessToken format, expected token to start with ${accessTokenPrefix}`,\n    )\n  }\n\n  return {\n    authorization: `Bearer ${personalAccessToken}`,\n    ...(workspaceId != null ? { 'seam-workspace': workspaceId } : {}),\n  }\n}\n\nconst getAuthHeadersForPublishableKey = (publishableKey: string): Headers => {\n  if (isJwt(publishableKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'A JWT cannot be used as a publishableKey',\n    )\n  }\n\n  if (isAccessToken(publishableKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'An Access Token cannot be used as a publishableKey',\n    )\n  }\n\n  if (isClientSessionToken(publishableKey)) {\n    throw new SeamHttpInvalidTokenError(\n      'A Client Session Token Key cannot be used as a publishableKey',\n    )\n  }\n\n  if (!isPublishableKey(publishableKey)) {\n    throw new SeamHttpInvalidTokenError(\n      `Unknown or invalid publishableKey format, expected token to start with ${publishableKeyTokenPrefix}`,\n    )\n  }\n\n  return {\n    'seam-publishable-key': publishableKey,\n  }\n}\n\nexport class SeamHttpInvalidTokenError extends Error {\n  constructor(message: string) {\n    super(`SeamHttp received an invalid token: ${message}`)\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport const warnOnInsecureuserIdentifierKey = (\n  userIdentifierKey: string,\n): void => {\n  if (isEmail(userIdentifierKey)) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      ...[\n        'Using an email for the userIdentifierKey is insecure and may return an error in the future!',\n        'This is insecure because an email is common knowledge or easily guessed.',\n        'Use something with sufficient entropy known only to the owner of the client session.',\n        'For help choosing a user identifier key see',\n        'https://docs.seam.co/latest/seam-components/overview/get-started-with-client-side-components#3-select-a-user-identifier-key',\n      ],\n    )\n  }\n}\n\n// SOURCE: https://stackoverflow.com/a/46181\nconst isEmail = (value: string): boolean =>\n  /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)\n","import { type AxiosError, isAxiosError } from 'axios'\n\nimport type { ApiErrorResponse } from './api-error-types.js'\nimport {\n  SeamHttpApiError,\n  SeamHttpInvalidInputError,\n  SeamHttpUnauthorizedError,\n} from './seam-http-error.js'\n\nexport const errorInterceptor = async (err: unknown): Promise<void> => {\n  if (!isAxiosError(err)) throw err\n\n  const { response } = err\n  const status = response?.status\n\n  const requestId = getRequestId(err)\n\n  if (status == null) throw err\n\n  if (status === 401) {\n    throw new SeamHttpUnauthorizedError(requestId)\n  }\n\n  if (!isApiErrorResponse(response)) throw err\n\n  const { type } = response.data.error\n\n  const args = [response.data.error, status, requestId] as const\n\n  if (type === 'invalid_input') throw new SeamHttpInvalidInputError(...args)\n  throw new SeamHttpApiError(...args)\n}\n\nconst isApiErrorResponse = (\n  response: AxiosError['response'],\n): response is NonNullable<AxiosError<ApiErrorResponse>['response']> => {\n  if (response == null) return false\n  const { headers, data } = response\n\n  if (headers == null) return false\n\n  const contentType = headers['Content-Type']\n  if (\n    typeof contentType === 'string' &&\n    !contentType.startsWith('application/json')\n  ) {\n    return false\n  }\n\n  if (typeof data === 'object' && data != null) {\n    return (\n      'error' in data &&\n      typeof data.error === 'object' &&\n      data.error != null &&\n      'type' in data.error &&\n      typeof data.error.type === 'string'\n    )\n  }\n\n  return false\n}\n\nconst getRequestId = (err: AxiosError): string => {\n  const headers = err.response?.headers\n  if (headers == null) return ''\n  const requestId = headers['seam-request-id']\n  if (requestId == null) return ''\n  return requestId\n}\n","import type { ApiError } from './api-error-types.js'\n\nexport class SeamHttpApiError extends Error {\n  code: string\n  statusCode: number\n  requestId: string\n  data?: unknown\n\n  constructor(error: ApiError, statusCode: number, requestId: string) {\n    const { type, message, data } = error\n    super(message)\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n    this.code = type\n    this.statusCode = statusCode\n    this.requestId = requestId\n    if (data != null) this.data = data\n  }\n}\n\nexport const isSeamHttpApiError = (\n  error: unknown,\n): error is SeamHttpApiError => {\n  return error instanceof SeamHttpApiError\n}\n\nexport class SeamHttpUnauthorizedError extends SeamHttpApiError {\n  override code: 'unauthorized'\n  override statusCode: 401\n\n  constructor(requestId: string) {\n    const type = 'unauthorized'\n    const status = 401\n    super({ type, message: 'Unauthorized' }, status, requestId)\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n    this.code = type\n    this.statusCode = status\n    this.requestId = requestId\n  }\n}\n\nexport const isSeamHttpUnauthorizedError = (\n  error: unknown,\n): error is SeamHttpUnauthorizedError => {\n  return error instanceof SeamHttpUnauthorizedError\n}\n\nexport class SeamHttpInvalidInputError extends SeamHttpApiError {\n  override code: 'invalid_input'\n\n  constructor(error: ApiError, statusCode: number, requestId: string) {\n    super(error, statusCode, requestId)\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n    this.code = 'invalid_input'\n  }\n}\n\nexport const isSeamHttpInvalidInputError = (\n  error: unknown,\n): error is SeamHttpInvalidInputError => {\n  return error instanceof SeamHttpInvalidInputError\n}\n","import { serializeUrlSearchParams } from '@seamapi/url-search-params-serializer'\nimport axios, { type AxiosInstance, type AxiosRequestConfig } from 'axios'\nimport axiosBetterStacktrace from 'axios-better-stacktrace'\nimport axiosRetry, { type AxiosRetry, exponentialDelay } from 'axios-retry'\n\nimport { errorInterceptor } from './error-interceptor.js'\n\nexport type Client = AxiosInstance\n\nexport interface ClientOptions {\n  axiosOptions?: AxiosRequestConfig\n  axiosRetryOptions?: AxiosRetryConfig\n}\n\ntype AxiosRetryConfig = Parameters<AxiosRetry>[1]\n\nexport const createClient = (options: ClientOptions): AxiosInstance => {\n  const client = axios.create({\n    paramsSerializer: serializeUrlSearchParams,\n    ...options.axiosOptions,\n  })\n\n  axiosBetterStacktrace(axios)\n\n  axiosRetry(client, {\n    retries: 2,\n    retryDelay: exponentialDelay,\n    ...options.axiosRetryOptions,\n  })\n\n  client.interceptors.response.use(undefined, errorInterceptor)\n\n  return client\n}\n","import type { openapi } from '@seamapi/types/connect'\n\nimport { createClient } from './client.js'\nimport { defaultEndpoint, sdkHeaders } from './parse-options.js'\n\nexport const getOpenapiSchema = async (\n  endpoint = defaultEndpoint,\n): Promise<typeof openapi> => {\n  const client = createClient({\n    axiosOptions: {\n      baseURL: endpoint,\n      headers: sdkHeaders,\n    },\n  })\n  const { data } = await client.get<typeof openapi>('/openapi.json')\n  return data\n}\n","import type {\n  ActionAttempt,\n  FailedActionAttempt,\n  SuccessfulActionAttempt,\n} from './action-attempt-types.js'\nimport type { SeamHttpActionAttempts } from './routes/index.js'\n\nexport interface ResolveActionAttemptOptions {\n  timeout?: number\n  pollingInterval?: number\n}\n\nexport const resolveActionAttempt = async <T extends ActionAttempt>(\n  actionAttempt: T,\n  actionAttempts: SeamHttpActionAttempts,\n  { timeout = 5000, pollingInterval = 500 }: ResolveActionAttemptOptions,\n): Promise<SuccessfulActionAttempt<T>> => {\n  let timeoutRef\n  const timeoutPromise = new Promise<SuccessfulActionAttempt<T>>(\n    (_resolve, reject) => {\n      timeoutRef = globalThis.setTimeout(() => {\n        reject(new SeamActionAttemptTimeoutError<T>(actionAttempt, timeout))\n      }, timeout)\n    },\n  )\n\n  try {\n    return await Promise.race([\n      pollActionAttempt<T>(actionAttempt, actionAttempts, { pollingInterval }),\n      timeoutPromise,\n    ])\n  } finally {\n    if (timeoutRef != null) globalThis.clearTimeout(timeoutRef)\n  }\n}\n\nconst pollActionAttempt = async <T extends ActionAttempt>(\n  actionAttempt: T,\n  actionAttempts: SeamHttpActionAttempts,\n  options: Pick<ResolveActionAttemptOptions, 'pollingInterval'>,\n): Promise<SuccessfulActionAttempt<T>> => {\n  if (isSuccessfulActionAttempt(actionAttempt)) {\n    return actionAttempt\n  }\n\n  if (isFailedActionAttempt(actionAttempt)) {\n    throw new SeamActionAttemptFailedError(actionAttempt)\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, options.pollingInterval))\n\n  const nextActionAttempt = await actionAttempts.get({\n    action_attempt_id: actionAttempt.action_attempt_id,\n  })\n\n  return await pollActionAttempt(\n    nextActionAttempt as unknown as T,\n    actionAttempts,\n    options,\n  )\n}\n\nexport const isSeamActionAttemptError = <T extends ActionAttempt>(\n  error: unknown,\n): error is SeamActionAttemptError<T> => {\n  return error instanceof SeamActionAttemptError\n}\n\nexport class SeamActionAttemptError<T extends ActionAttempt> extends Error {\n  actionAttempt: T\n\n  constructor(message: string, actionAttempt: T) {\n    super(message)\n    this.name = this.constructor.name\n    this.actionAttempt = actionAttempt\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport const isSeamActionAttemptFailedError = <T extends ActionAttempt>(\n  error: unknown,\n): error is SeamActionAttemptFailedError<T> => {\n  return error instanceof SeamActionAttemptFailedError\n}\n\nexport class SeamActionAttemptFailedError<\n  T extends ActionAttempt,\n> extends SeamActionAttemptError<T> {\n  code: string\n\n  constructor(actionAttempt: FailedActionAttempt<T>) {\n    super(actionAttempt.error.message, actionAttempt)\n    this.name = this.constructor.name\n    this.code = actionAttempt.error.type\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport const isSeamActionAttemptTimeoutError = <T extends ActionAttempt>(\n  error: unknown,\n): error is SeamActionAttemptTimeoutError<T> => {\n  return error instanceof SeamActionAttemptTimeoutError\n}\n\nexport class SeamActionAttemptTimeoutError<\n  T extends ActionAttempt,\n> extends SeamActionAttemptError<T> {\n  constructor(actionAttempt: T, timeout: number) {\n    super(\n      `Timed out waiting for action action attempt after ${timeout}ms`,\n      actionAttempt,\n    )\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nconst isSuccessfulActionAttempt = <T extends ActionAttempt>(\n  actionAttempt: T,\n): actionAttempt is SuccessfulActionAttempt<T> =>\n  actionAttempt.status === 'success'\n\nconst isFailedActionAttempt = <T extends ActionAttempt>(\n  actionAttempt: T,\n): actionAttempt is FailedActionAttempt<T> => actionAttempt.status === 'error'\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nexport class SeamHttpClientSessions {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpClientSessions {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpClientSessions(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpClientSessions {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpClientSessions(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpClientSessions {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpClientSessions(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpClientSessions> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpClientSessions.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpClientSessions {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpClientSessions(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpClientSessions {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpClientSessions(constructorOptions)\n  }\n\n  async create(\n    body?: ClientSessionsCreateBody,\n  ): Promise<ClientSessionsCreateResponse['client_session']> {\n    const { data } = await this.client.request<ClientSessionsCreateResponse>({\n      url: '/client_sessions/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.client_session\n  }\n\n  async delete(body?: ClientSessionsDeleteBody): Promise<void> {\n    await this.client.request<ClientSessionsDeleteResponse>({\n      url: '/client_sessions/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: ClientSessionsGetParams,\n  ): Promise<ClientSessionsGetResponse['client_session']> {\n    const { data } = await this.client.request<ClientSessionsGetResponse>({\n      url: '/client_sessions/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.client_session\n  }\n\n  async getOrCreate(\n    body?: ClientSessionsGetOrCreateBody,\n  ): Promise<ClientSessionsGetOrCreateResponse['client_session']> {\n    const { data } =\n      await this.client.request<ClientSessionsGetOrCreateResponse>({\n        url: '/client_sessions/get_or_create',\n        method: 'post',\n        data: body,\n      })\n\n    return data.client_session\n  }\n\n  async grantAccess(\n    body?: ClientSessionsGrantAccessBody,\n  ): Promise<ClientSessionsGrantAccessResponse['client_session']> {\n    const { data } =\n      await this.client.request<ClientSessionsGrantAccessResponse>({\n        url: '/client_sessions/grant_access',\n        method: 'post',\n        data: body,\n      })\n\n    return data.client_session\n  }\n\n  async list(\n    body?: ClientSessionsListParams,\n  ): Promise<ClientSessionsListResponse['client_sessions']> {\n    const { data } = await this.client.request<ClientSessionsListResponse>({\n      url: '/client_sessions/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.client_sessions\n  }\n\n  async revoke(body?: ClientSessionsRevokeBody): Promise<void> {\n    await this.client.request<ClientSessionsRevokeResponse>({\n      url: '/client_sessions/revoke',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type ClientSessionsCreateBody =\n  RouteRequestBody<'/client_sessions/create'>\n\nexport type ClientSessionsCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/create'>>\n>\n\nexport type ClientSessionsCreateOptions = never\n\nexport type ClientSessionsDeleteBody =\n  RouteRequestBody<'/client_sessions/delete'>\n\nexport type ClientSessionsDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/delete'>>\n>\n\nexport type ClientSessionsDeleteOptions = never\n\nexport type ClientSessionsGetParams = RouteRequestBody<'/client_sessions/get'>\n\nexport type ClientSessionsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/get'>>\n>\n\nexport type ClientSessionsGetOptions = never\n\nexport type ClientSessionsGetOrCreateBody =\n  RouteRequestBody<'/client_sessions/get_or_create'>\n\nexport type ClientSessionsGetOrCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/get_or_create'>>\n>\n\nexport type ClientSessionsGetOrCreateOptions = never\n\nexport type ClientSessionsGrantAccessBody =\n  RouteRequestBody<'/client_sessions/grant_access'>\n\nexport type ClientSessionsGrantAccessResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/grant_access'>>\n>\n\nexport type ClientSessionsGrantAccessOptions = never\n\nexport type ClientSessionsListParams = RouteRequestBody<'/client_sessions/list'>\n\nexport type ClientSessionsListResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/list'>>\n>\n\nexport type ClientSessionsListOptions = never\n\nexport type ClientSessionsRevokeBody =\n  RouteRequestBody<'/client_sessions/revoke'>\n\nexport type ClientSessionsRevokeResponse = SetNonNullable<\n  Required<RouteResponse<'/client_sessions/revoke'>>\n>\n\nexport type ClientSessionsRevokeOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAccessCodesUnmanaged {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAccessCodesUnmanaged {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAccessCodesUnmanaged(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAccessCodesUnmanaged {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAccessCodesUnmanaged(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAccessCodesUnmanaged {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAccessCodesUnmanaged(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAccessCodesUnmanaged> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAccessCodesUnmanaged.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAccessCodesUnmanaged {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAccessCodesUnmanaged(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAccessCodesUnmanaged {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAccessCodesUnmanaged(constructorOptions)\n  }\n\n  async convertToManaged(\n    body?: AccessCodesUnmanagedConvertToManagedBody,\n  ): Promise<void> {\n    await this.client.request<AccessCodesUnmanagedConvertToManagedResponse>({\n      url: '/access_codes/unmanaged/convert_to_managed',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async delete(body?: AccessCodesUnmanagedDeleteBody): Promise<void> {\n    await this.client.request<AccessCodesUnmanagedDeleteResponse>({\n      url: '/access_codes/unmanaged/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: AccessCodesUnmanagedGetParams,\n  ): Promise<AccessCodesUnmanagedGetResponse['access_code']> {\n    const { data } = await this.client.request<AccessCodesUnmanagedGetResponse>(\n      {\n        url: '/access_codes/unmanaged/get',\n        method: 'post',\n        data: body,\n      },\n    )\n\n    return data.access_code\n  }\n\n  async list(\n    body?: AccessCodesUnmanagedListParams,\n  ): Promise<AccessCodesUnmanagedListResponse['access_codes']> {\n    const { data } =\n      await this.client.request<AccessCodesUnmanagedListResponse>({\n        url: '/access_codes/unmanaged/list',\n        method: 'post',\n        data: body,\n      })\n\n    return data.access_codes\n  }\n\n  async update(body?: AccessCodesUnmanagedUpdateBody): Promise<void> {\n    await this.client.request<AccessCodesUnmanagedUpdateResponse>({\n      url: '/access_codes/unmanaged/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type AccessCodesUnmanagedConvertToManagedBody =\n  RouteRequestBody<'/access_codes/unmanaged/convert_to_managed'>\n\nexport type AccessCodesUnmanagedConvertToManagedResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/unmanaged/convert_to_managed'>>\n>\n\nexport type AccessCodesUnmanagedConvertToManagedOptions = never\n\nexport type AccessCodesUnmanagedDeleteBody =\n  RouteRequestBody<'/access_codes/unmanaged/delete'>\n\nexport type AccessCodesUnmanagedDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/unmanaged/delete'>>\n>\n\nexport type AccessCodesUnmanagedDeleteOptions = never\n\nexport type AccessCodesUnmanagedGetParams =\n  RouteRequestBody<'/access_codes/unmanaged/get'>\n\nexport type AccessCodesUnmanagedGetResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/unmanaged/get'>>\n>\n\nexport type AccessCodesUnmanagedGetOptions = never\n\nexport type AccessCodesUnmanagedListParams =\n  RouteRequestBody<'/access_codes/unmanaged/list'>\n\nexport type AccessCodesUnmanagedListResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/unmanaged/list'>>\n>\n\nexport type AccessCodesUnmanagedListOptions = never\n\nexport type AccessCodesUnmanagedUpdateBody =\n  RouteRequestBody<'/access_codes/unmanaged/update'>\n\nexport type AccessCodesUnmanagedUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/unmanaged/update'>>\n>\n\nexport type AccessCodesUnmanagedUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpAccessCodesUnmanaged } from './access-codes-unmanaged.js'\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAccessCodes {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAccessCodes {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAccessCodes(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAccessCodes {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAccessCodes(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAccessCodes {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAccessCodes(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAccessCodes> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAccessCodes.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAccessCodes {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAccessCodes(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAccessCodes {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAccessCodes(constructorOptions)\n  }\n\n  get unmanaged(): SeamHttpAccessCodesUnmanaged {\n    return SeamHttpAccessCodesUnmanaged.fromClient(this.client, this.defaults)\n  }\n\n  async create(\n    body?: AccessCodesCreateBody,\n  ): Promise<AccessCodesCreateResponse['access_code']> {\n    const { data } = await this.client.request<AccessCodesCreateResponse>({\n      url: '/access_codes/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.access_code\n  }\n\n  async createMultiple(\n    body?: AccessCodesCreateMultipleBody,\n  ): Promise<AccessCodesCreateMultipleResponse['access_codes']> {\n    const { data } =\n      await this.client.request<AccessCodesCreateMultipleResponse>({\n        url: '/access_codes/create_multiple',\n        method: 'post',\n        data: body,\n      })\n\n    return data.access_codes\n  }\n\n  async delete(body?: AccessCodesDeleteBody): Promise<void> {\n    await this.client.request<AccessCodesDeleteResponse>({\n      url: '/access_codes/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async generateCode(\n    body?: AccessCodesGenerateCodeBody,\n  ): Promise<AccessCodesGenerateCodeResponse['generated_code']> {\n    const { data } = await this.client.request<AccessCodesGenerateCodeResponse>(\n      {\n        url: '/access_codes/generate_code',\n        method: 'post',\n        data: body,\n      },\n    )\n\n    return data.generated_code\n  }\n\n  async get(\n    body?: AccessCodesGetParams,\n  ): Promise<AccessCodesGetResponse['access_code']> {\n    const { data } = await this.client.request<AccessCodesGetResponse>({\n      url: '/access_codes/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.access_code\n  }\n\n  async list(\n    body?: AccessCodesListParams,\n  ): Promise<AccessCodesListResponse['access_codes']> {\n    const { data } = await this.client.request<AccessCodesListResponse>({\n      url: '/access_codes/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.access_codes\n  }\n\n  async pullBackupAccessCode(\n    body?: AccessCodesPullBackupAccessCodeBody,\n  ): Promise<AccessCodesPullBackupAccessCodeResponse['backup_access_code']> {\n    const { data } =\n      await this.client.request<AccessCodesPullBackupAccessCodeResponse>({\n        url: '/access_codes/pull_backup_access_code',\n        method: 'post',\n        data: body,\n      })\n\n    return data.backup_access_code\n  }\n\n  async update(body?: AccessCodesUpdateBody): Promise<void> {\n    await this.client.request<AccessCodesUpdateResponse>({\n      url: '/access_codes/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type AccessCodesCreateBody = RouteRequestBody<'/access_codes/create'>\n\nexport type AccessCodesCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/create'>>\n>\n\nexport type AccessCodesCreateOptions = never\n\nexport type AccessCodesCreateMultipleBody =\n  RouteRequestBody<'/access_codes/create_multiple'>\n\nexport type AccessCodesCreateMultipleResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/create_multiple'>>\n>\n\nexport type AccessCodesCreateMultipleOptions = never\n\nexport type AccessCodesDeleteBody = RouteRequestBody<'/access_codes/delete'>\n\nexport type AccessCodesDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/delete'>>\n>\n\nexport type AccessCodesDeleteOptions = never\n\nexport type AccessCodesGenerateCodeBody =\n  RouteRequestBody<'/access_codes/generate_code'>\n\nexport type AccessCodesGenerateCodeResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/generate_code'>>\n>\n\nexport type AccessCodesGenerateCodeOptions = never\n\nexport type AccessCodesGetParams = RouteRequestBody<'/access_codes/get'>\n\nexport type AccessCodesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/get'>>\n>\n\nexport type AccessCodesGetOptions = never\n\nexport type AccessCodesListParams = RouteRequestBody<'/access_codes/list'>\n\nexport type AccessCodesListResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/list'>>\n>\n\nexport type AccessCodesListOptions = never\n\nexport type AccessCodesPullBackupAccessCodeBody =\n  RouteRequestBody<'/access_codes/pull_backup_access_code'>\n\nexport type AccessCodesPullBackupAccessCodeResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/pull_backup_access_code'>>\n>\n\nexport type AccessCodesPullBackupAccessCodeOptions = never\n\nexport type AccessCodesUpdateBody = RouteRequestBody<'/access_codes/update'>\n\nexport type AccessCodesUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/access_codes/update'>>\n>\n\nexport type AccessCodesUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsAccessGroups {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsAccessGroups {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsAccessGroups(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsAccessGroups {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsAccessGroups(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsAccessGroups {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsAccessGroups(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsAccessGroups> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsAccessGroups.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsAccessGroups {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsAccessGroups(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsAccessGroups {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsAccessGroups(constructorOptions)\n  }\n\n  async addUser(body?: AcsAccessGroupsAddUserBody): Promise<void> {\n    await this.client.request<AcsAccessGroupsAddUserResponse>({\n      url: '/acs/access_groups/add_user',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: AcsAccessGroupsGetParams,\n  ): Promise<AcsAccessGroupsGetResponse['acs_access_group']> {\n    const { data } = await this.client.request<AcsAccessGroupsGetResponse>({\n      url: '/acs/access_groups/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_access_group\n  }\n\n  async list(\n    body?: AcsAccessGroupsListParams,\n  ): Promise<AcsAccessGroupsListResponse['acs_access_groups']> {\n    const { data } = await this.client.request<AcsAccessGroupsListResponse>({\n      url: '/acs/access_groups/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_access_groups\n  }\n\n  async listUsers(\n    body?: AcsAccessGroupsListUsersParams,\n  ): Promise<AcsAccessGroupsListUsersResponse['acs_users']> {\n    const { data } =\n      await this.client.request<AcsAccessGroupsListUsersResponse>({\n        url: '/acs/access_groups/list_users',\n        method: 'post',\n        data: body,\n      })\n\n    return data.acs_users\n  }\n\n  async removeUser(body?: AcsAccessGroupsRemoveUserBody): Promise<void> {\n    await this.client.request<AcsAccessGroupsRemoveUserResponse>({\n      url: '/acs/access_groups/remove_user',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type AcsAccessGroupsAddUserBody =\n  RouteRequestBody<'/acs/access_groups/add_user'>\n\nexport type AcsAccessGroupsAddUserResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/access_groups/add_user'>>\n>\n\nexport type AcsAccessGroupsAddUserOptions = never\n\nexport type AcsAccessGroupsGetParams =\n  RouteRequestBody<'/acs/access_groups/get'>\n\nexport type AcsAccessGroupsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/access_groups/get'>>\n>\n\nexport type AcsAccessGroupsGetOptions = never\n\nexport type AcsAccessGroupsListParams =\n  RouteRequestBody<'/acs/access_groups/list'>\n\nexport type AcsAccessGroupsListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/access_groups/list'>>\n>\n\nexport type AcsAccessGroupsListOptions = never\n\nexport type AcsAccessGroupsListUsersParams =\n  RouteRequestBody<'/acs/access_groups/list_users'>\n\nexport type AcsAccessGroupsListUsersResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/access_groups/list_users'>>\n>\n\nexport type AcsAccessGroupsListUsersOptions = never\n\nexport type AcsAccessGroupsRemoveUserBody =\n  RouteRequestBody<'/acs/access_groups/remove_user'>\n\nexport type AcsAccessGroupsRemoveUserResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/access_groups/remove_user'>>\n>\n\nexport type AcsAccessGroupsRemoveUserOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsCredentialPools {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsCredentialPools {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsCredentialPools(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsCredentialPools {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsCredentialPools(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsCredentialPools {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsCredentialPools(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsCredentialPools> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsCredentialPools.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentialPools {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentialPools(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentialPools {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentialPools(constructorOptions)\n  }\n\n  async list(\n    body?: AcsCredentialPoolsListParams,\n  ): Promise<AcsCredentialPoolsListResponse['acs_credential_pools']> {\n    const { data } = await this.client.request<AcsCredentialPoolsListResponse>({\n      url: '/acs/credential_pools/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential_pools\n  }\n}\n\nexport type AcsCredentialPoolsListParams =\n  RouteRequestBody<'/acs/credential_pools/list'>\n\nexport type AcsCredentialPoolsListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credential_pools/list'>>\n>\n\nexport type AcsCredentialPoolsListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsCredentialProvisioningAutomations {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsCredentialProvisioningAutomations {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsCredentialProvisioningAutomations(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsCredentialProvisioningAutomations {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsCredentialProvisioningAutomations(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsCredentialProvisioningAutomations {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsCredentialProvisioningAutomations(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsCredentialProvisioningAutomations> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsCredentialProvisioningAutomations.fromClientSessionToken(\n      token,\n      options,\n    )\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentialProvisioningAutomations {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentialProvisioningAutomations(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentialProvisioningAutomations {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentialProvisioningAutomations(constructorOptions)\n  }\n\n  async launch(\n    body?: AcsCredentialProvisioningAutomationsLaunchBody,\n  ): Promise<\n    AcsCredentialProvisioningAutomationsLaunchResponse['acs_credential_provisioning_automation']\n  > {\n    const { data } =\n      await this.client.request<AcsCredentialProvisioningAutomationsLaunchResponse>(\n        {\n          url: '/acs/credential_provisioning_automations/launch',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.acs_credential_provisioning_automation\n  }\n}\n\nexport type AcsCredentialProvisioningAutomationsLaunchBody =\n  RouteRequestBody<'/acs/credential_provisioning_automations/launch'>\n\nexport type AcsCredentialProvisioningAutomationsLaunchResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credential_provisioning_automations/launch'>>\n>\n\nexport type AcsCredentialProvisioningAutomationsLaunchOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsCredentials {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsCredentials {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsCredentials(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsCredentials {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsCredentials(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsCredentials {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsCredentials(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsCredentials> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsCredentials.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentials {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentials(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsCredentials {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsCredentials(constructorOptions)\n  }\n\n  async assign(\n    body?: AcsCredentialsAssignBody,\n  ): Promise<AcsCredentialsAssignResponse['acs_credential']> {\n    const { data } = await this.client.request<AcsCredentialsAssignResponse>({\n      url: '/acs/credentials/assign',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential\n  }\n\n  async create(\n    body?: AcsCredentialsCreateBody,\n  ): Promise<AcsCredentialsCreateResponse['acs_credential']> {\n    const { data } = await this.client.request<AcsCredentialsCreateResponse>({\n      url: '/acs/credentials/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential\n  }\n\n  async delete(body?: AcsCredentialsDeleteBody): Promise<void> {\n    await this.client.request<AcsCredentialsDeleteResponse>({\n      url: '/acs/credentials/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: AcsCredentialsGetParams,\n  ): Promise<AcsCredentialsGetResponse['acs_credential']> {\n    const { data } = await this.client.request<AcsCredentialsGetResponse>({\n      url: '/acs/credentials/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential\n  }\n\n  async list(\n    body?: AcsCredentialsListParams,\n  ): Promise<AcsCredentialsListResponse['acs_credentials']> {\n    const { data } = await this.client.request<AcsCredentialsListResponse>({\n      url: '/acs/credentials/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credentials\n  }\n\n  async unassign(\n    body?: AcsCredentialsUnassignBody,\n  ): Promise<AcsCredentialsUnassignResponse['acs_credential']> {\n    const { data } = await this.client.request<AcsCredentialsUnassignResponse>({\n      url: '/acs/credentials/unassign',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential\n  }\n\n  async update(\n    body?: AcsCredentialsUpdateBody,\n  ): Promise<AcsCredentialsUpdateResponse['acs_credential']> {\n    const { data } = await this.client.request<AcsCredentialsUpdateResponse>({\n      url: '/acs/credentials/update',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_credential\n  }\n}\n\nexport type AcsCredentialsAssignBody =\n  RouteRequestBody<'/acs/credentials/assign'>\n\nexport type AcsCredentialsAssignResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/assign'>>\n>\n\nexport type AcsCredentialsAssignOptions = never\n\nexport type AcsCredentialsCreateBody =\n  RouteRequestBody<'/acs/credentials/create'>\n\nexport type AcsCredentialsCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/create'>>\n>\n\nexport type AcsCredentialsCreateOptions = never\n\nexport type AcsCredentialsDeleteBody =\n  RouteRequestBody<'/acs/credentials/delete'>\n\nexport type AcsCredentialsDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/delete'>>\n>\n\nexport type AcsCredentialsDeleteOptions = never\n\nexport type AcsCredentialsGetParams = RouteRequestBody<'/acs/credentials/get'>\n\nexport type AcsCredentialsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/get'>>\n>\n\nexport type AcsCredentialsGetOptions = never\n\nexport type AcsCredentialsListParams = RouteRequestBody<'/acs/credentials/list'>\n\nexport type AcsCredentialsListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/list'>>\n>\n\nexport type AcsCredentialsListOptions = never\n\nexport type AcsCredentialsUnassignBody =\n  RouteRequestBody<'/acs/credentials/unassign'>\n\nexport type AcsCredentialsUnassignResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/unassign'>>\n>\n\nexport type AcsCredentialsUnassignOptions = never\n\nexport type AcsCredentialsUpdateBody =\n  RouteRequestBody<'/acs/credentials/update'>\n\nexport type AcsCredentialsUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/credentials/update'>>\n>\n\nexport type AcsCredentialsUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsEntrances {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsEntrances {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsEntrances(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsEntrances {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsEntrances(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsEntrances {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsEntrances(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsEntrances> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsEntrances.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsEntrances {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsEntrances(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsEntrances {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsEntrances(constructorOptions)\n  }\n\n  async get(\n    body?: AcsEntrancesGetParams,\n  ): Promise<AcsEntrancesGetResponse['acs_entrance']> {\n    const { data } = await this.client.request<AcsEntrancesGetResponse>({\n      url: '/acs/entrances/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_entrance\n  }\n\n  async grantAccess(body?: AcsEntrancesGrantAccessBody): Promise<void> {\n    await this.client.request<AcsEntrancesGrantAccessResponse>({\n      url: '/acs/entrances/grant_access',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async list(\n    body?: AcsEntrancesListParams,\n  ): Promise<AcsEntrancesListResponse['acs_entrances']> {\n    const { data } = await this.client.request<AcsEntrancesListResponse>({\n      url: '/acs/entrances/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_entrances\n  }\n}\n\nexport type AcsEntrancesGetParams = RouteRequestBody<'/acs/entrances/get'>\n\nexport type AcsEntrancesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/entrances/get'>>\n>\n\nexport type AcsEntrancesGetOptions = never\n\nexport type AcsEntrancesGrantAccessBody =\n  RouteRequestBody<'/acs/entrances/grant_access'>\n\nexport type AcsEntrancesGrantAccessResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/entrances/grant_access'>>\n>\n\nexport type AcsEntrancesGrantAccessOptions = never\n\nexport type AcsEntrancesListParams = RouteRequestBody<'/acs/entrances/list'>\n\nexport type AcsEntrancesListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/entrances/list'>>\n>\n\nexport type AcsEntrancesListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsSystems {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsSystems {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsSystems(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsSystems {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsSystems(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsSystems {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsSystems(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsSystems> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsSystems.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsSystems {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsSystems(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsSystems {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsSystems(constructorOptions)\n  }\n\n  async get(\n    body?: AcsSystemsGetParams,\n  ): Promise<AcsSystemsGetResponse['acs_system']> {\n    const { data } = await this.client.request<AcsSystemsGetResponse>({\n      url: '/acs/systems/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_system\n  }\n\n  async list(\n    body?: AcsSystemsListParams,\n  ): Promise<AcsSystemsListResponse['acs_systems']> {\n    const { data } = await this.client.request<AcsSystemsListResponse>({\n      url: '/acs/systems/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_systems\n  }\n}\n\nexport type AcsSystemsGetParams = RouteRequestBody<'/acs/systems/get'>\n\nexport type AcsSystemsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/systems/get'>>\n>\n\nexport type AcsSystemsGetOptions = never\n\nexport type AcsSystemsListParams = RouteRequestBody<'/acs/systems/list'>\n\nexport type AcsSystemsListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/systems/list'>>\n>\n\nexport type AcsSystemsListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcsUsers {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcsUsers {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcsUsers(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcsUsers {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcsUsers(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcsUsers {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcsUsers(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcsUsers> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcsUsers.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsUsers {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsUsers(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcsUsers {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcsUsers(constructorOptions)\n  }\n\n  async addToAccessGroup(body?: AcsUsersAddToAccessGroupBody): Promise<void> {\n    await this.client.request<AcsUsersAddToAccessGroupResponse>({\n      url: '/acs/users/add_to_access_group',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async create(\n    body?: AcsUsersCreateBody,\n  ): Promise<AcsUsersCreateResponse['acs_user']> {\n    const { data } = await this.client.request<AcsUsersCreateResponse>({\n      url: '/acs/users/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_user\n  }\n\n  async delete(body?: AcsUsersDeleteBody): Promise<void> {\n    await this.client.request<AcsUsersDeleteResponse>({\n      url: '/acs/users/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: AcsUsersGetParams,\n  ): Promise<AcsUsersGetResponse['acs_user']> {\n    const { data } = await this.client.request<AcsUsersGetResponse>({\n      url: '/acs/users/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_user\n  }\n\n  async list(\n    body?: AcsUsersListParams,\n  ): Promise<AcsUsersListResponse['acs_users']> {\n    const { data } = await this.client.request<AcsUsersListResponse>({\n      url: '/acs/users/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.acs_users\n  }\n\n  async listAccessibleEntrances(\n    body?: AcsUsersListAccessibleEntrancesParams,\n  ): Promise<AcsUsersListAccessibleEntrancesResponse['acs_entrances']> {\n    const { data } =\n      await this.client.request<AcsUsersListAccessibleEntrancesResponse>({\n        url: '/acs/users/list_accessible_entrances',\n        method: 'post',\n        data: body,\n      })\n\n    return data.acs_entrances\n  }\n\n  async removeFromAccessGroup(\n    body?: AcsUsersRemoveFromAccessGroupBody,\n  ): Promise<void> {\n    await this.client.request<AcsUsersRemoveFromAccessGroupResponse>({\n      url: '/acs/users/remove_from_access_group',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async suspend(body?: AcsUsersSuspendBody): Promise<void> {\n    await this.client.request<AcsUsersSuspendResponse>({\n      url: '/acs/users/suspend',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async unsuspend(body?: AcsUsersUnsuspendBody): Promise<void> {\n    await this.client.request<AcsUsersUnsuspendResponse>({\n      url: '/acs/users/unsuspend',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async update(body?: AcsUsersUpdateBody): Promise<void> {\n    await this.client.request<AcsUsersUpdateResponse>({\n      url: '/acs/users/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type AcsUsersAddToAccessGroupBody =\n  RouteRequestBody<'/acs/users/add_to_access_group'>\n\nexport type AcsUsersAddToAccessGroupResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/add_to_access_group'>>\n>\n\nexport type AcsUsersAddToAccessGroupOptions = never\n\nexport type AcsUsersCreateBody = RouteRequestBody<'/acs/users/create'>\n\nexport type AcsUsersCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/create'>>\n>\n\nexport type AcsUsersCreateOptions = never\n\nexport type AcsUsersDeleteBody = RouteRequestBody<'/acs/users/delete'>\n\nexport type AcsUsersDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/delete'>>\n>\n\nexport type AcsUsersDeleteOptions = never\n\nexport type AcsUsersGetParams = RouteRequestBody<'/acs/users/get'>\n\nexport type AcsUsersGetResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/get'>>\n>\n\nexport type AcsUsersGetOptions = never\n\nexport type AcsUsersListParams = RouteRequestBody<'/acs/users/list'>\n\nexport type AcsUsersListResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/list'>>\n>\n\nexport type AcsUsersListOptions = never\n\nexport type AcsUsersListAccessibleEntrancesParams =\n  RouteRequestBody<'/acs/users/list_accessible_entrances'>\n\nexport type AcsUsersListAccessibleEntrancesResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/list_accessible_entrances'>>\n>\n\nexport type AcsUsersListAccessibleEntrancesOptions = never\n\nexport type AcsUsersRemoveFromAccessGroupBody =\n  RouteRequestBody<'/acs/users/remove_from_access_group'>\n\nexport type AcsUsersRemoveFromAccessGroupResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/remove_from_access_group'>>\n>\n\nexport type AcsUsersRemoveFromAccessGroupOptions = never\n\nexport type AcsUsersSuspendBody = RouteRequestBody<'/acs/users/suspend'>\n\nexport type AcsUsersSuspendResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/suspend'>>\n>\n\nexport type AcsUsersSuspendOptions = never\n\nexport type AcsUsersUnsuspendBody = RouteRequestBody<'/acs/users/unsuspend'>\n\nexport type AcsUsersUnsuspendResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/unsuspend'>>\n>\n\nexport type AcsUsersUnsuspendOptions = never\n\nexport type AcsUsersUpdateBody = RouteRequestBody<'/acs/users/update'>\n\nexport type AcsUsersUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/acs/users/update'>>\n>\n\nexport type AcsUsersUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpAcsAccessGroups } from './acs-access-groups.js'\nimport { SeamHttpAcsCredentialPools } from './acs-credential-pools.js'\nimport { SeamHttpAcsCredentialProvisioningAutomations } from './acs-credential-provisioning-automations.js'\nimport { SeamHttpAcsCredentials } from './acs-credentials.js'\nimport { SeamHttpAcsEntrances } from './acs-entrances.js'\nimport { SeamHttpAcsSystems } from './acs-systems.js'\nimport { SeamHttpAcsUsers } from './acs-users.js'\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpAcs {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpAcs {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpAcs(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpAcs {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpAcs(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpAcs {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpAcs(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpAcs> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpAcs.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcs {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcs(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpAcs {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpAcs(constructorOptions)\n  }\n\n  get accessGroups(): SeamHttpAcsAccessGroups {\n    return SeamHttpAcsAccessGroups.fromClient(this.client, this.defaults)\n  }\n\n  get credentialPools(): SeamHttpAcsCredentialPools {\n    return SeamHttpAcsCredentialPools.fromClient(this.client, this.defaults)\n  }\n\n  get credentialProvisioningAutomations(): SeamHttpAcsCredentialProvisioningAutomations {\n    return SeamHttpAcsCredentialProvisioningAutomations.fromClient(\n      this.client,\n      this.defaults,\n    )\n  }\n\n  get credentials(): SeamHttpAcsCredentials {\n    return SeamHttpAcsCredentials.fromClient(this.client, this.defaults)\n  }\n\n  get entrances(): SeamHttpAcsEntrances {\n    return SeamHttpAcsEntrances.fromClient(this.client, this.defaults)\n  }\n\n  get systems(): SeamHttpAcsSystems {\n    return SeamHttpAcsSystems.fromClient(this.client, this.defaults)\n  }\n\n  get users(): SeamHttpAcsUsers {\n    return SeamHttpAcsUsers.fromClient(this.client, this.defaults)\n  }\n}\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\nimport { resolveActionAttempt } from 'lib/seam/connect/resolve-action-attempt.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpActionAttempts {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpActionAttempts {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpActionAttempts(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpActionAttempts {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpActionAttempts(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpActionAttempts {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpActionAttempts(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpActionAttempts> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpActionAttempts.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpActionAttempts {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpActionAttempts(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpActionAttempts {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpActionAttempts(constructorOptions)\n  }\n\n  async get(\n    body?: ActionAttemptsGetParams,\n    options: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'> = {},\n  ): Promise<ActionAttemptsGetResponse['action_attempt']> {\n    const { data } = await this.client.request<ActionAttemptsGetResponse>({\n      url: '/action_attempts/get',\n      method: 'post',\n      data: body,\n    })\n    const waitForActionAttempt =\n      options.waitForActionAttempt ?? this.defaults.waitForActionAttempt\n    if (waitForActionAttempt !== false) {\n      return await resolveActionAttempt(\n        data.action_attempt,\n        SeamHttpActionAttempts.fromClient(this.client, {\n          ...this.defaults,\n          waitForActionAttempt: false,\n        }),\n        typeof waitForActionAttempt === 'boolean' ? {} : waitForActionAttempt,\n      )\n    }\n    return data.action_attempt\n  }\n\n  async list(\n    body?: ActionAttemptsListParams,\n  ): Promise<ActionAttemptsListResponse['action_attempts']> {\n    const { data } = await this.client.request<ActionAttemptsListResponse>({\n      url: '/action_attempts/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.action_attempts\n  }\n}\n\nexport type ActionAttemptsGetParams = RouteRequestBody<'/action_attempts/get'>\n\nexport type ActionAttemptsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/action_attempts/get'>>\n>\n\nexport type ActionAttemptsGetOptions = Pick<\n  SeamHttpRequestOptions,\n  'waitForActionAttempt'\n>\n\nexport type ActionAttemptsListParams = RouteRequestBody<'/action_attempts/list'>\n\nexport type ActionAttemptsListResponse = SetNonNullable<\n  Required<RouteResponse<'/action_attempts/list'>>\n>\n\nexport type ActionAttemptsListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type {\n  RouteRequestBody,\n  RouteRequestParams,\n  RouteResponse,\n} from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpConnectWebviews {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpConnectWebviews {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpConnectWebviews(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpConnectWebviews {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpConnectWebviews(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpConnectWebviews {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpConnectWebviews(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpConnectWebviews> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpConnectWebviews.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpConnectWebviews {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpConnectWebviews(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpConnectWebviews {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpConnectWebviews(constructorOptions)\n  }\n\n  async create(\n    body?: ConnectWebviewsCreateBody,\n  ): Promise<ConnectWebviewsCreateResponse['connect_webview']> {\n    const { data } = await this.client.request<ConnectWebviewsCreateResponse>({\n      url: '/connect_webviews/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.connect_webview\n  }\n\n  async delete(body?: ConnectWebviewsDeleteBody): Promise<void> {\n    await this.client.request<ConnectWebviewsDeleteResponse>({\n      url: '/connect_webviews/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: ConnectWebviewsGetParams,\n  ): Promise<ConnectWebviewsGetResponse['connect_webview']> {\n    const { data } = await this.client.request<ConnectWebviewsGetResponse>({\n      url: '/connect_webviews/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.connect_webview\n  }\n\n  async list(\n    body?: ConnectWebviewsListParams,\n  ): Promise<ConnectWebviewsListResponse['connect_webviews']> {\n    const { data } = await this.client.request<ConnectWebviewsListResponse>({\n      url: '/connect_webviews/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.connect_webviews\n  }\n\n  async view(params?: ConnectWebviewsViewParams): Promise<void> {\n    await this.client.request<ConnectWebviewsViewResponse>({\n      url: '/connect_webviews/view',\n      method: 'get',\n      params,\n    })\n  }\n}\n\nexport type ConnectWebviewsCreateBody =\n  RouteRequestBody<'/connect_webviews/create'>\n\nexport type ConnectWebviewsCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/connect_webviews/create'>>\n>\n\nexport type ConnectWebviewsCreateOptions = never\n\nexport type ConnectWebviewsDeleteBody =\n  RouteRequestBody<'/connect_webviews/delete'>\n\nexport type ConnectWebviewsDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/connect_webviews/delete'>>\n>\n\nexport type ConnectWebviewsDeleteOptions = never\n\nexport type ConnectWebviewsGetParams = RouteRequestBody<'/connect_webviews/get'>\n\nexport type ConnectWebviewsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/connect_webviews/get'>>\n>\n\nexport type ConnectWebviewsGetOptions = never\n\nexport type ConnectWebviewsListParams =\n  RouteRequestBody<'/connect_webviews/list'>\n\nexport type ConnectWebviewsListResponse = SetNonNullable<\n  Required<RouteResponse<'/connect_webviews/list'>>\n>\n\nexport type ConnectWebviewsListOptions = never\n\nexport type ConnectWebviewsViewParams =\n  RouteRequestParams<'/connect_webviews/view'>\n\nexport type ConnectWebviewsViewResponse = SetNonNullable<\n  Required<RouteResponse<'/connect_webviews/view'>>\n>\n\nexport type ConnectWebviewsViewOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpConnectedAccounts {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpConnectedAccounts {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpConnectedAccounts(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpConnectedAccounts {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpConnectedAccounts(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpConnectedAccounts {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpConnectedAccounts(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpConnectedAccounts> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpConnectedAccounts.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpConnectedAccounts {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpConnectedAccounts(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpConnectedAccounts {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpConnectedAccounts(constructorOptions)\n  }\n\n  async delete(body?: ConnectedAccountsDeleteBody): Promise<void> {\n    await this.client.request<ConnectedAccountsDeleteResponse>({\n      url: '/connected_accounts/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: ConnectedAccountsGetParams,\n  ): Promise<ConnectedAccountsGetResponse['connected_account']> {\n    const { data } = await this.client.request<ConnectedAccountsGetResponse>({\n      url: '/connected_accounts/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.connected_account\n  }\n\n  async list(\n    body?: ConnectedAccountsListParams,\n  ): Promise<ConnectedAccountsListResponse['connected_accounts']> {\n    const { data } = await this.client.request<ConnectedAccountsListResponse>({\n      url: '/connected_accounts/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.connected_accounts\n  }\n\n  async update(\n    body?: ConnectedAccountsUpdateBody,\n  ): Promise<ConnectedAccountsUpdateResponse['connected_account']> {\n    const { data } = await this.client.request<ConnectedAccountsUpdateResponse>(\n      {\n        url: '/connected_accounts/update',\n        method: 'post',\n        data: body,\n      },\n    )\n\n    return data.connected_account\n  }\n}\n\nexport type ConnectedAccountsDeleteBody =\n  RouteRequestBody<'/connected_accounts/delete'>\n\nexport type ConnectedAccountsDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/connected_accounts/delete'>>\n>\n\nexport type ConnectedAccountsDeleteOptions = never\n\nexport type ConnectedAccountsGetParams =\n  RouteRequestBody<'/connected_accounts/get'>\n\nexport type ConnectedAccountsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/connected_accounts/get'>>\n>\n\nexport type ConnectedAccountsGetOptions = never\n\nexport type ConnectedAccountsListParams =\n  RouteRequestBody<'/connected_accounts/list'>\n\nexport type ConnectedAccountsListResponse = SetNonNullable<\n  Required<RouteResponse<'/connected_accounts/list'>>\n>\n\nexport type ConnectedAccountsListOptions = never\n\nexport type ConnectedAccountsUpdateBody =\n  RouteRequestBody<'/connected_accounts/update'>\n\nexport type ConnectedAccountsUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/connected_accounts/update'>>\n>\n\nexport type ConnectedAccountsUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpDevicesUnmanaged {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpDevicesUnmanaged {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpDevicesUnmanaged(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpDevicesUnmanaged {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpDevicesUnmanaged(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpDevicesUnmanaged {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpDevicesUnmanaged(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpDevicesUnmanaged> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpDevicesUnmanaged.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpDevicesUnmanaged {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpDevicesUnmanaged(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpDevicesUnmanaged {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpDevicesUnmanaged(constructorOptions)\n  }\n\n  async get(\n    body?: DevicesUnmanagedGetParams,\n  ): Promise<DevicesUnmanagedGetResponse['device']> {\n    const { data } = await this.client.request<DevicesUnmanagedGetResponse>({\n      url: '/devices/unmanaged/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.device\n  }\n\n  async list(\n    body?: DevicesUnmanagedListParams,\n  ): Promise<DevicesUnmanagedListResponse['devices']> {\n    const { data } = await this.client.request<DevicesUnmanagedListResponse>({\n      url: '/devices/unmanaged/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.devices\n  }\n\n  async update(body?: DevicesUnmanagedUpdateBody): Promise<void> {\n    await this.client.request<DevicesUnmanagedUpdateResponse>({\n      url: '/devices/unmanaged/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type DevicesUnmanagedGetParams =\n  RouteRequestBody<'/devices/unmanaged/get'>\n\nexport type DevicesUnmanagedGetResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/unmanaged/get'>>\n>\n\nexport type DevicesUnmanagedGetOptions = never\n\nexport type DevicesUnmanagedListParams =\n  RouteRequestBody<'/devices/unmanaged/list'>\n\nexport type DevicesUnmanagedListResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/unmanaged/list'>>\n>\n\nexport type DevicesUnmanagedListOptions = never\n\nexport type DevicesUnmanagedUpdateBody =\n  RouteRequestBody<'/devices/unmanaged/update'>\n\nexport type DevicesUnmanagedUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/unmanaged/update'>>\n>\n\nexport type DevicesUnmanagedUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\nimport { SeamHttpDevicesUnmanaged } from './devices-unmanaged.js'\n\nexport class SeamHttpDevices {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpDevices {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpDevices(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpDevices {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpDevices(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpDevices {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpDevices(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpDevices> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpDevices.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpDevices {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpDevices(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpDevices {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpDevices(constructorOptions)\n  }\n\n  get unmanaged(): SeamHttpDevicesUnmanaged {\n    return SeamHttpDevicesUnmanaged.fromClient(this.client, this.defaults)\n  }\n\n  async delete(body?: DevicesDeleteBody): Promise<void> {\n    await this.client.request<DevicesDeleteResponse>({\n      url: '/devices/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(body?: DevicesGetParams): Promise<DevicesGetResponse['device']> {\n    const { data } = await this.client.request<DevicesGetResponse>({\n      url: '/devices/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.device\n  }\n\n  async list(\n    body?: DevicesListParams,\n  ): Promise<DevicesListResponse['devices']> {\n    const { data } = await this.client.request<DevicesListResponse>({\n      url: '/devices/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.devices\n  }\n\n  async listDeviceProviders(\n    body?: DevicesListDeviceProvidersParams,\n  ): Promise<DevicesListDeviceProvidersResponse['device_providers']> {\n    const { data } =\n      await this.client.request<DevicesListDeviceProvidersResponse>({\n        url: '/devices/list_device_providers',\n        method: 'post',\n        data: body,\n      })\n\n    return data.device_providers\n  }\n\n  async update(body?: DevicesUpdateBody): Promise<void> {\n    await this.client.request<DevicesUpdateResponse>({\n      url: '/devices/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type DevicesDeleteBody = RouteRequestBody<'/devices/delete'>\n\nexport type DevicesDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/delete'>>\n>\n\nexport type DevicesDeleteOptions = never\n\nexport type DevicesGetParams = RouteRequestBody<'/devices/get'>\n\nexport type DevicesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/get'>>\n>\n\nexport type DevicesGetOptions = never\n\nexport type DevicesListParams = RouteRequestBody<'/devices/list'>\n\nexport type DevicesListResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/list'>>\n>\n\nexport type DevicesListOptions = never\n\nexport type DevicesListDeviceProvidersParams =\n  RouteRequestBody<'/devices/list_device_providers'>\n\nexport type DevicesListDeviceProvidersResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/list_device_providers'>>\n>\n\nexport type DevicesListDeviceProvidersOptions = never\n\nexport type DevicesUpdateBody = RouteRequestBody<'/devices/update'>\n\nexport type DevicesUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/devices/update'>>\n>\n\nexport type DevicesUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpEvents {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpEvents {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpEvents(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpEvents {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpEvents(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpEvents {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpEvents(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpEvents> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpEvents.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpEvents {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpEvents(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpEvents {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpEvents(constructorOptions)\n  }\n\n  async get(body?: EventsGetParams): Promise<EventsGetResponse['event']> {\n    const { data } = await this.client.request<EventsGetResponse>({\n      url: '/events/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.event\n  }\n\n  async list(body?: EventsListParams): Promise<EventsListResponse['events']> {\n    const { data } = await this.client.request<EventsListResponse>({\n      url: '/events/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.events\n  }\n}\n\nexport type EventsGetParams = RouteRequestBody<'/events/get'>\n\nexport type EventsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/events/get'>>\n>\n\nexport type EventsGetOptions = never\n\nexport type EventsListParams = RouteRequestBody<'/events/list'>\n\nexport type EventsListResponse = SetNonNullable<\n  Required<RouteResponse<'/events/list'>>\n>\n\nexport type EventsListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\nimport { resolveActionAttempt } from 'lib/seam/connect/resolve-action-attempt.js'\n\nimport { SeamHttpActionAttempts } from './action-attempts.js'\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpLocks {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpLocks {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpLocks(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpLocks {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpLocks(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpLocks {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpLocks(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpLocks> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpLocks.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpLocks {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpLocks(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpLocks {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpLocks(constructorOptions)\n  }\n\n  async get(body?: LocksGetParams): Promise<LocksGetResponse['device']> {\n    const { data } = await this.client.request<LocksGetResponse>({\n      url: '/locks/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.device\n  }\n\n  async list(body?: LocksListParams): Promise<LocksListResponse['devices']> {\n    const { data } = await this.client.request<LocksListResponse>({\n      url: '/locks/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.devices\n  }\n\n  async lockDoor(\n    body?: LocksLockDoorBody,\n    options: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'> = {},\n  ): Promise<LocksLockDoorResponse['action_attempt']> {\n    const { data } = await this.client.request<LocksLockDoorResponse>({\n      url: '/locks/lock_door',\n      method: 'post',\n      data: body,\n    })\n    const waitForActionAttempt =\n      options.waitForActionAttempt ?? this.defaults.waitForActionAttempt\n    if (waitForActionAttempt !== false) {\n      return await resolveActionAttempt(\n        data.action_attempt,\n        SeamHttpActionAttempts.fromClient(this.client, {\n          ...this.defaults,\n          waitForActionAttempt: false,\n        }),\n        typeof waitForActionAttempt === 'boolean' ? {} : waitForActionAttempt,\n      )\n    }\n    return data.action_attempt\n  }\n\n  async unlockDoor(\n    body?: LocksUnlockDoorBody,\n    options: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'> = {},\n  ): Promise<LocksUnlockDoorResponse['action_attempt']> {\n    const { data } = await this.client.request<LocksUnlockDoorResponse>({\n      url: '/locks/unlock_door',\n      method: 'post',\n      data: body,\n    })\n    const waitForActionAttempt =\n      options.waitForActionAttempt ?? this.defaults.waitForActionAttempt\n    if (waitForActionAttempt !== false) {\n      return await resolveActionAttempt(\n        data.action_attempt,\n        SeamHttpActionAttempts.fromClient(this.client, {\n          ...this.defaults,\n          waitForActionAttempt: false,\n        }),\n        typeof waitForActionAttempt === 'boolean' ? {} : waitForActionAttempt,\n      )\n    }\n    return data.action_attempt\n  }\n}\n\nexport type LocksGetParams = RouteRequestBody<'/locks/get'>\n\nexport type LocksGetResponse = SetNonNullable<\n  Required<RouteResponse<'/locks/get'>>\n>\n\nexport type LocksGetOptions = never\n\nexport type LocksListParams = RouteRequestBody<'/locks/list'>\n\nexport type LocksListResponse = SetNonNullable<\n  Required<RouteResponse<'/locks/list'>>\n>\n\nexport type LocksListOptions = never\n\nexport type LocksLockDoorBody = RouteRequestBody<'/locks/lock_door'>\n\nexport type LocksLockDoorResponse = SetNonNullable<\n  Required<RouteResponse<'/locks/lock_door'>>\n>\n\nexport type LocksLockDoorOptions = Pick<\n  SeamHttpRequestOptions,\n  'waitForActionAttempt'\n>\n\nexport type LocksUnlockDoorBody = RouteRequestBody<'/locks/unlock_door'>\n\nexport type LocksUnlockDoorResponse = SetNonNullable<\n  Required<RouteResponse<'/locks/unlock_door'>>\n>\n\nexport type LocksUnlockDoorOptions = Pick<\n  SeamHttpRequestOptions,\n  'waitForActionAttempt'\n>\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpNetworks {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpNetworks {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpNetworks(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpNetworks {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpNetworks(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpNetworks {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpNetworks(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpNetworks> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpNetworks.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNetworks {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpNetworks(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNetworks {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpNetworks(constructorOptions)\n  }\n\n  async get(body?: NetworksGetParams): Promise<NetworksGetResponse['network']> {\n    const { data } = await this.client.request<NetworksGetResponse>({\n      url: '/networks/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.network\n  }\n\n  async list(\n    body?: NetworksListParams,\n  ): Promise<NetworksListResponse['networks']> {\n    const { data } = await this.client.request<NetworksListResponse>({\n      url: '/networks/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.networks\n  }\n}\n\nexport type NetworksGetParams = RouteRequestBody<'/networks/get'>\n\nexport type NetworksGetResponse = SetNonNullable<\n  Required<RouteResponse<'/networks/get'>>\n>\n\nexport type NetworksGetOptions = never\n\nexport type NetworksListParams = RouteRequestBody<'/networks/list'>\n\nexport type NetworksListResponse = SetNonNullable<\n  Required<RouteResponse<'/networks/list'>>\n>\n\nexport type NetworksListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpNoiseSensorsNoiseThresholds {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpNoiseSensorsNoiseThresholds {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpNoiseSensorsNoiseThresholds(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpNoiseSensorsNoiseThresholds {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpNoiseSensorsNoiseThresholds(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpNoiseSensorsNoiseThresholds {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpNoiseSensorsNoiseThresholds(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpNoiseSensorsNoiseThresholds> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpNoiseSensorsNoiseThresholds.fromClientSessionToken(\n      token,\n      options,\n    )\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNoiseSensorsNoiseThresholds {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpNoiseSensorsNoiseThresholds(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNoiseSensorsNoiseThresholds {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpNoiseSensorsNoiseThresholds(constructorOptions)\n  }\n\n  async create(\n    body?: NoiseSensorsNoiseThresholdsCreateBody,\n  ): Promise<NoiseSensorsNoiseThresholdsCreateResponse['noise_threshold']> {\n    const { data } =\n      await this.client.request<NoiseSensorsNoiseThresholdsCreateResponse>({\n        url: '/noise_sensors/noise_thresholds/create',\n        method: 'post',\n        data: body,\n      })\n\n    return data.noise_threshold\n  }\n\n  async delete(body?: NoiseSensorsNoiseThresholdsDeleteBody): Promise<void> {\n    await this.client.request<NoiseSensorsNoiseThresholdsDeleteResponse>({\n      url: '/noise_sensors/noise_thresholds/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: NoiseSensorsNoiseThresholdsGetParams,\n  ): Promise<NoiseSensorsNoiseThresholdsGetResponse['noise_threshold']> {\n    const { data } =\n      await this.client.request<NoiseSensorsNoiseThresholdsGetResponse>({\n        url: '/noise_sensors/noise_thresholds/get',\n        method: 'post',\n        data: body,\n      })\n\n    return data.noise_threshold\n  }\n\n  async list(\n    body?: NoiseSensorsNoiseThresholdsListParams,\n  ): Promise<NoiseSensorsNoiseThresholdsListResponse['noise_thresholds']> {\n    const { data } =\n      await this.client.request<NoiseSensorsNoiseThresholdsListResponse>({\n        url: '/noise_sensors/noise_thresholds/list',\n        method: 'post',\n        data: body,\n      })\n\n    return data.noise_thresholds\n  }\n\n  async update(body?: NoiseSensorsNoiseThresholdsUpdateBody): Promise<void> {\n    await this.client.request<NoiseSensorsNoiseThresholdsUpdateResponse>({\n      url: '/noise_sensors/noise_thresholds/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type NoiseSensorsNoiseThresholdsCreateBody =\n  RouteRequestBody<'/noise_sensors/noise_thresholds/create'>\n\nexport type NoiseSensorsNoiseThresholdsCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/noise_sensors/noise_thresholds/create'>>\n>\n\nexport type NoiseSensorsNoiseThresholdsCreateOptions = never\n\nexport type NoiseSensorsNoiseThresholdsDeleteBody =\n  RouteRequestBody<'/noise_sensors/noise_thresholds/delete'>\n\nexport type NoiseSensorsNoiseThresholdsDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/noise_sensors/noise_thresholds/delete'>>\n>\n\nexport type NoiseSensorsNoiseThresholdsDeleteOptions = never\n\nexport type NoiseSensorsNoiseThresholdsGetParams =\n  RouteRequestBody<'/noise_sensors/noise_thresholds/get'>\n\nexport type NoiseSensorsNoiseThresholdsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/noise_sensors/noise_thresholds/get'>>\n>\n\nexport type NoiseSensorsNoiseThresholdsGetOptions = never\n\nexport type NoiseSensorsNoiseThresholdsListParams =\n  RouteRequestBody<'/noise_sensors/noise_thresholds/list'>\n\nexport type NoiseSensorsNoiseThresholdsListResponse = SetNonNullable<\n  Required<RouteResponse<'/noise_sensors/noise_thresholds/list'>>\n>\n\nexport type NoiseSensorsNoiseThresholdsListOptions = never\n\nexport type NoiseSensorsNoiseThresholdsUpdateBody =\n  RouteRequestBody<'/noise_sensors/noise_thresholds/update'>\n\nexport type NoiseSensorsNoiseThresholdsUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/noise_sensors/noise_thresholds/update'>>\n>\n\nexport type NoiseSensorsNoiseThresholdsUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\nimport { SeamHttpNoiseSensorsNoiseThresholds } from './noise-sensors-noise-thresholds.js'\n\nexport class SeamHttpNoiseSensors {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpNoiseSensors {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpNoiseSensors(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpNoiseSensors {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpNoiseSensors(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpNoiseSensors {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpNoiseSensors(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpNoiseSensors> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpNoiseSensors.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNoiseSensors {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpNoiseSensors(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpNoiseSensors {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpNoiseSensors(constructorOptions)\n  }\n\n  get noiseThresholds(): SeamHttpNoiseSensorsNoiseThresholds {\n    return SeamHttpNoiseSensorsNoiseThresholds.fromClient(\n      this.client,\n      this.defaults,\n    )\n  }\n}\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpPhones {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpPhones {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpPhones(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpPhones {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpPhones(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpPhones {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpPhones(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpPhones> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpPhones.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpPhones {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpPhones(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpPhones {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpPhones(constructorOptions)\n  }\n\n  async list(body?: PhonesListParams): Promise<PhonesListResponse['phones']> {\n    const { data } = await this.client.request<PhonesListResponse>({\n      url: '/phones/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.phones\n  }\n}\n\nexport type PhonesListParams = RouteRequestBody<'/phones/list'>\n\nexport type PhonesListResponse = SetNonNullable<\n  Required<RouteResponse<'/phones/list'>>\n>\n\nexport type PhonesListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpThermostatsClimateSettingSchedules {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpThermostatsClimateSettingSchedules {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpThermostatsClimateSettingSchedules(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpThermostatsClimateSettingSchedules {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpThermostatsClimateSettingSchedules(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpThermostatsClimateSettingSchedules {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpThermostatsClimateSettingSchedules(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpThermostatsClimateSettingSchedules> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpThermostatsClimateSettingSchedules.fromClientSessionToken(\n      token,\n      options,\n    )\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpThermostatsClimateSettingSchedules {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpThermostatsClimateSettingSchedules(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpThermostatsClimateSettingSchedules {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpThermostatsClimateSettingSchedules(constructorOptions)\n  }\n\n  async create(\n    body?: ThermostatsClimateSettingSchedulesCreateBody,\n  ): Promise<\n    ThermostatsClimateSettingSchedulesCreateResponse['climate_setting_schedule']\n  > {\n    const { data } =\n      await this.client.request<ThermostatsClimateSettingSchedulesCreateResponse>(\n        {\n          url: '/thermostats/climate_setting_schedules/create',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.climate_setting_schedule\n  }\n\n  async delete(\n    body?: ThermostatsClimateSettingSchedulesDeleteBody,\n  ): Promise<void> {\n    await this.client.request<ThermostatsClimateSettingSchedulesDeleteResponse>(\n      {\n        url: '/thermostats/climate_setting_schedules/delete',\n        method: 'post',\n        data: body,\n      },\n    )\n  }\n\n  async get(\n    body?: ThermostatsClimateSettingSchedulesGetParams,\n  ): Promise<\n    ThermostatsClimateSettingSchedulesGetResponse['climate_setting_schedule']\n  > {\n    const { data } =\n      await this.client.request<ThermostatsClimateSettingSchedulesGetResponse>({\n        url: '/thermostats/climate_setting_schedules/get',\n        method: 'post',\n        data: body,\n      })\n\n    return data.climate_setting_schedule\n  }\n\n  async list(\n    body?: ThermostatsClimateSettingSchedulesListParams,\n  ): Promise<\n    ThermostatsClimateSettingSchedulesListResponse['climate_setting_schedules']\n  > {\n    const { data } =\n      await this.client.request<ThermostatsClimateSettingSchedulesListResponse>(\n        {\n          url: '/thermostats/climate_setting_schedules/list',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.climate_setting_schedules\n  }\n\n  async update(\n    body?: ThermostatsClimateSettingSchedulesUpdateBody,\n  ): Promise<void> {\n    await this.client.request<ThermostatsClimateSettingSchedulesUpdateResponse>(\n      {\n        url: '/thermostats/climate_setting_schedules/update',\n        method: 'post',\n        data: body,\n      },\n    )\n  }\n}\n\nexport type ThermostatsClimateSettingSchedulesCreateBody =\n  RouteRequestBody<'/thermostats/climate_setting_schedules/create'>\n\nexport type ThermostatsClimateSettingSchedulesCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/climate_setting_schedules/create'>>\n>\n\nexport type ThermostatsClimateSettingSchedulesCreateOptions = never\n\nexport type ThermostatsClimateSettingSchedulesDeleteBody =\n  RouteRequestBody<'/thermostats/climate_setting_schedules/delete'>\n\nexport type ThermostatsClimateSettingSchedulesDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/climate_setting_schedules/delete'>>\n>\n\nexport type ThermostatsClimateSettingSchedulesDeleteOptions = never\n\nexport type ThermostatsClimateSettingSchedulesGetParams =\n  RouteRequestBody<'/thermostats/climate_setting_schedules/get'>\n\nexport type ThermostatsClimateSettingSchedulesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/climate_setting_schedules/get'>>\n>\n\nexport type ThermostatsClimateSettingSchedulesGetOptions = never\n\nexport type ThermostatsClimateSettingSchedulesListParams =\n  RouteRequestBody<'/thermostats/climate_setting_schedules/list'>\n\nexport type ThermostatsClimateSettingSchedulesListResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/climate_setting_schedules/list'>>\n>\n\nexport type ThermostatsClimateSettingSchedulesListOptions = never\n\nexport type ThermostatsClimateSettingSchedulesUpdateBody =\n  RouteRequestBody<'/thermostats/climate_setting_schedules/update'>\n\nexport type ThermostatsClimateSettingSchedulesUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/climate_setting_schedules/update'>>\n>\n\nexport type ThermostatsClimateSettingSchedulesUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\nimport { SeamHttpThermostatsClimateSettingSchedules } from './thermostats-climate-setting-schedules.js'\n\nexport class SeamHttpThermostats {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpThermostats {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpThermostats(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpThermostats {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpThermostats(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpThermostats {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpThermostats(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpThermostats> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpThermostats.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpThermostats {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpThermostats(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpThermostats {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpThermostats(constructorOptions)\n  }\n\n  get climateSettingSchedules(): SeamHttpThermostatsClimateSettingSchedules {\n    return SeamHttpThermostatsClimateSettingSchedules.fromClient(\n      this.client,\n      this.defaults,\n    )\n  }\n\n  async cool(body?: ThermostatsCoolBody): Promise<void> {\n    await this.client.request<ThermostatsCoolResponse>({\n      url: '/thermostats/cool',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(\n    body?: ThermostatsGetParams,\n  ): Promise<ThermostatsGetResponse['thermostat']> {\n    const { data } = await this.client.request<ThermostatsGetResponse>({\n      url: '/thermostats/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.thermostat\n  }\n\n  async heat(body?: ThermostatsHeatBody): Promise<void> {\n    await this.client.request<ThermostatsHeatResponse>({\n      url: '/thermostats/heat',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async heatCool(body?: ThermostatsHeatCoolBody): Promise<void> {\n    await this.client.request<ThermostatsHeatCoolResponse>({\n      url: '/thermostats/heat_cool',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async list(\n    body?: ThermostatsListParams,\n  ): Promise<ThermostatsListResponse['thermostats']> {\n    const { data } = await this.client.request<ThermostatsListResponse>({\n      url: '/thermostats/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.thermostats\n  }\n\n  async off(body?: ThermostatsOffBody): Promise<void> {\n    await this.client.request<ThermostatsOffResponse>({\n      url: '/thermostats/off',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async setFanMode(body?: ThermostatsSetFanModeBody): Promise<void> {\n    await this.client.request<ThermostatsSetFanModeResponse>({\n      url: '/thermostats/set_fan_mode',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async update(body?: ThermostatsUpdateBody): Promise<void> {\n    await this.client.request<ThermostatsUpdateResponse>({\n      url: '/thermostats/update',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type ThermostatsCoolBody = RouteRequestBody<'/thermostats/cool'>\n\nexport type ThermostatsCoolResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/cool'>>\n>\n\nexport type ThermostatsCoolOptions = never\n\nexport type ThermostatsGetParams = RouteRequestBody<'/thermostats/get'>\n\nexport type ThermostatsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/get'>>\n>\n\nexport type ThermostatsGetOptions = never\n\nexport type ThermostatsHeatBody = RouteRequestBody<'/thermostats/heat'>\n\nexport type ThermostatsHeatResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/heat'>>\n>\n\nexport type ThermostatsHeatOptions = never\n\nexport type ThermostatsHeatCoolBody = RouteRequestBody<'/thermostats/heat_cool'>\n\nexport type ThermostatsHeatCoolResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/heat_cool'>>\n>\n\nexport type ThermostatsHeatCoolOptions = never\n\nexport type ThermostatsListParams = RouteRequestBody<'/thermostats/list'>\n\nexport type ThermostatsListResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/list'>>\n>\n\nexport type ThermostatsListOptions = never\n\nexport type ThermostatsOffBody = RouteRequestBody<'/thermostats/off'>\n\nexport type ThermostatsOffResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/off'>>\n>\n\nexport type ThermostatsOffOptions = never\n\nexport type ThermostatsSetFanModeBody =\n  RouteRequestBody<'/thermostats/set_fan_mode'>\n\nexport type ThermostatsSetFanModeResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/set_fan_mode'>>\n>\n\nexport type ThermostatsSetFanModeOptions = never\n\nexport type ThermostatsUpdateBody = RouteRequestBody<'/thermostats/update'>\n\nexport type ThermostatsUpdateResponse = SetNonNullable<\n  Required<RouteResponse<'/thermostats/update'>>\n>\n\nexport type ThermostatsUpdateOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpUserIdentitiesEnrollmentAutomations {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpUserIdentitiesEnrollmentAutomations {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpUserIdentitiesEnrollmentAutomations {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpUserIdentitiesEnrollmentAutomations {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpUserIdentitiesEnrollmentAutomations> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpUserIdentitiesEnrollmentAutomations.fromClientSessionToken(\n      token,\n      options,\n    )\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpUserIdentitiesEnrollmentAutomations {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpUserIdentitiesEnrollmentAutomations {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions)\n  }\n\n  async get(\n    body?: UserIdentitiesEnrollmentAutomationsGetParams,\n  ): Promise<\n    UserIdentitiesEnrollmentAutomationsGetResponse['enrollment_automation']\n  > {\n    const { data } =\n      await this.client.request<UserIdentitiesEnrollmentAutomationsGetResponse>(\n        {\n          url: '/user_identities/enrollment_automations/get',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.enrollment_automation\n  }\n\n  async launch(\n    body?: UserIdentitiesEnrollmentAutomationsLaunchBody,\n  ): Promise<\n    UserIdentitiesEnrollmentAutomationsLaunchResponse['enrollment_automation']\n  > {\n    const { data } =\n      await this.client.request<UserIdentitiesEnrollmentAutomationsLaunchResponse>(\n        {\n          url: '/user_identities/enrollment_automations/launch',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.enrollment_automation\n  }\n\n  async list(\n    body?: UserIdentitiesEnrollmentAutomationsListParams,\n  ): Promise<\n    UserIdentitiesEnrollmentAutomationsListResponse['enrollment_automations']\n  > {\n    const { data } =\n      await this.client.request<UserIdentitiesEnrollmentAutomationsListResponse>(\n        {\n          url: '/user_identities/enrollment_automations/list',\n          method: 'post',\n          data: body,\n        },\n      )\n\n    return data.enrollment_automations\n  }\n}\n\nexport type UserIdentitiesEnrollmentAutomationsGetParams =\n  RouteRequestBody<'/user_identities/enrollment_automations/get'>\n\nexport type UserIdentitiesEnrollmentAutomationsGetResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/enrollment_automations/get'>>\n>\n\nexport type UserIdentitiesEnrollmentAutomationsGetOptions = never\n\nexport type UserIdentitiesEnrollmentAutomationsLaunchBody =\n  RouteRequestBody<'/user_identities/enrollment_automations/launch'>\n\nexport type UserIdentitiesEnrollmentAutomationsLaunchResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/enrollment_automations/launch'>>\n>\n\nexport type UserIdentitiesEnrollmentAutomationsLaunchOptions = never\n\nexport type UserIdentitiesEnrollmentAutomationsListParams =\n  RouteRequestBody<'/user_identities/enrollment_automations/list'>\n\nexport type UserIdentitiesEnrollmentAutomationsListResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/enrollment_automations/list'>>\n>\n\nexport type UserIdentitiesEnrollmentAutomationsListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\nimport { SeamHttpUserIdentitiesEnrollmentAutomations } from './user-identities-enrollment-automations.js'\n\nexport class SeamHttpUserIdentities {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpUserIdentities {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpUserIdentities(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpUserIdentities {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpUserIdentities(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpUserIdentities {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpUserIdentities(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpUserIdentities> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpUserIdentities.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpUserIdentities {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpUserIdentities(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpUserIdentities {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpUserIdentities(constructorOptions)\n  }\n\n  get enrollmentAutomations(): SeamHttpUserIdentitiesEnrollmentAutomations {\n    return SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(\n      this.client,\n      this.defaults,\n    )\n  }\n\n  async addAcsUser(body?: UserIdentitiesAddAcsUserBody): Promise<void> {\n    await this.client.request<UserIdentitiesAddAcsUserResponse>({\n      url: '/user_identities/add_acs_user',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async create(\n    body?: UserIdentitiesCreateBody,\n  ): Promise<UserIdentitiesCreateResponse['user_identity']> {\n    const { data } = await this.client.request<UserIdentitiesCreateResponse>({\n      url: '/user_identities/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.user_identity\n  }\n\n  async get(\n    body?: UserIdentitiesGetParams,\n  ): Promise<UserIdentitiesGetResponse['user_identity']> {\n    const { data } = await this.client.request<UserIdentitiesGetResponse>({\n      url: '/user_identities/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.user_identity\n  }\n\n  async grantAccessToDevice(\n    body?: UserIdentitiesGrantAccessToDeviceBody,\n  ): Promise<void> {\n    await this.client.request<UserIdentitiesGrantAccessToDeviceResponse>({\n      url: '/user_identities/grant_access_to_device',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async list(\n    body?: UserIdentitiesListParams,\n  ): Promise<UserIdentitiesListResponse['user_identities']> {\n    const { data } = await this.client.request<UserIdentitiesListResponse>({\n      url: '/user_identities/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.user_identities\n  }\n\n  async listAccessibleDevices(\n    body?: UserIdentitiesListAccessibleDevicesParams,\n  ): Promise<\n    UserIdentitiesListAccessibleDevicesResponse['accessible_devices']\n  > {\n    const { data } =\n      await this.client.request<UserIdentitiesListAccessibleDevicesResponse>({\n        url: '/user_identities/list_accessible_devices',\n        method: 'post',\n        data: body,\n      })\n\n    return data.accessible_devices\n  }\n\n  async listAcsSystems(\n    body?: UserIdentitiesListAcsSystemsParams,\n  ): Promise<UserIdentitiesListAcsSystemsResponse['acs_systems']> {\n    const { data } =\n      await this.client.request<UserIdentitiesListAcsSystemsResponse>({\n        url: '/user_identities/list_acs_systems',\n        method: 'post',\n        data: body,\n      })\n\n    return data.acs_systems\n  }\n\n  async listAcsUsers(\n    body?: UserIdentitiesListAcsUsersParams,\n  ): Promise<UserIdentitiesListAcsUsersResponse['acs_users']> {\n    const { data } =\n      await this.client.request<UserIdentitiesListAcsUsersResponse>({\n        url: '/user_identities/list_acs_users',\n        method: 'post',\n        data: body,\n      })\n\n    return data.acs_users\n  }\n\n  async removeAcsUser(body?: UserIdentitiesRemoveAcsUserBody): Promise<void> {\n    await this.client.request<UserIdentitiesRemoveAcsUserResponse>({\n      url: '/user_identities/remove_acs_user',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async revokeAccessToDevice(\n    body?: UserIdentitiesRevokeAccessToDeviceBody,\n  ): Promise<void> {\n    await this.client.request<UserIdentitiesRevokeAccessToDeviceResponse>({\n      url: '/user_identities/revoke_access_to_device',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type UserIdentitiesAddAcsUserBody =\n  RouteRequestBody<'/user_identities/add_acs_user'>\n\nexport type UserIdentitiesAddAcsUserResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/add_acs_user'>>\n>\n\nexport type UserIdentitiesAddAcsUserOptions = never\n\nexport type UserIdentitiesCreateBody =\n  RouteRequestBody<'/user_identities/create'>\n\nexport type UserIdentitiesCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/create'>>\n>\n\nexport type UserIdentitiesCreateOptions = never\n\nexport type UserIdentitiesGetParams = RouteRequestBody<'/user_identities/get'>\n\nexport type UserIdentitiesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/get'>>\n>\n\nexport type UserIdentitiesGetOptions = never\n\nexport type UserIdentitiesGrantAccessToDeviceBody =\n  RouteRequestBody<'/user_identities/grant_access_to_device'>\n\nexport type UserIdentitiesGrantAccessToDeviceResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/grant_access_to_device'>>\n>\n\nexport type UserIdentitiesGrantAccessToDeviceOptions = never\n\nexport type UserIdentitiesListParams = RouteRequestBody<'/user_identities/list'>\n\nexport type UserIdentitiesListResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/list'>>\n>\n\nexport type UserIdentitiesListOptions = never\n\nexport type UserIdentitiesListAccessibleDevicesParams =\n  RouteRequestBody<'/user_identities/list_accessible_devices'>\n\nexport type UserIdentitiesListAccessibleDevicesResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/list_accessible_devices'>>\n>\n\nexport type UserIdentitiesListAccessibleDevicesOptions = never\n\nexport type UserIdentitiesListAcsSystemsParams =\n  RouteRequestBody<'/user_identities/list_acs_systems'>\n\nexport type UserIdentitiesListAcsSystemsResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/list_acs_systems'>>\n>\n\nexport type UserIdentitiesListAcsSystemsOptions = never\n\nexport type UserIdentitiesListAcsUsersParams =\n  RouteRequestBody<'/user_identities/list_acs_users'>\n\nexport type UserIdentitiesListAcsUsersResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/list_acs_users'>>\n>\n\nexport type UserIdentitiesListAcsUsersOptions = never\n\nexport type UserIdentitiesRemoveAcsUserBody =\n  RouteRequestBody<'/user_identities/remove_acs_user'>\n\nexport type UserIdentitiesRemoveAcsUserResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/remove_acs_user'>>\n>\n\nexport type UserIdentitiesRemoveAcsUserOptions = never\n\nexport type UserIdentitiesRevokeAccessToDeviceBody =\n  RouteRequestBody<'/user_identities/revoke_access_to_device'>\n\nexport type UserIdentitiesRevokeAccessToDeviceResponse = SetNonNullable<\n  Required<RouteResponse<'/user_identities/revoke_access_to_device'>>\n>\n\nexport type UserIdentitiesRevokeAccessToDeviceOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpWebhooks {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpWebhooks {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpWebhooks(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpWebhooks {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpWebhooks(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpWebhooks {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpWebhooks(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpWebhooks> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpWebhooks.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpWebhooks {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpWebhooks(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpWebhooks {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpWebhooks(constructorOptions)\n  }\n\n  async create(\n    body?: WebhooksCreateBody,\n  ): Promise<WebhooksCreateResponse['webhook']> {\n    const { data } = await this.client.request<WebhooksCreateResponse>({\n      url: '/webhooks/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.webhook\n  }\n\n  async delete(body?: WebhooksDeleteBody): Promise<void> {\n    await this.client.request<WebhooksDeleteResponse>({\n      url: '/webhooks/delete',\n      method: 'post',\n      data: body,\n    })\n  }\n\n  async get(body?: WebhooksGetParams): Promise<WebhooksGetResponse['webhook']> {\n    const { data } = await this.client.request<WebhooksGetResponse>({\n      url: '/webhooks/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.webhook\n  }\n\n  async list(\n    body?: WebhooksListParams,\n  ): Promise<WebhooksListResponse['webhooks']> {\n    const { data } = await this.client.request<WebhooksListResponse>({\n      url: '/webhooks/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.webhooks\n  }\n}\n\nexport type WebhooksCreateBody = RouteRequestBody<'/webhooks/create'>\n\nexport type WebhooksCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/webhooks/create'>>\n>\n\nexport type WebhooksCreateOptions = never\n\nexport type WebhooksDeleteBody = RouteRequestBody<'/webhooks/delete'>\n\nexport type WebhooksDeleteResponse = SetNonNullable<\n  Required<RouteResponse<'/webhooks/delete'>>\n>\n\nexport type WebhooksDeleteOptions = never\n\nexport type WebhooksGetParams = RouteRequestBody<'/webhooks/get'>\n\nexport type WebhooksGetResponse = SetNonNullable<\n  Required<RouteResponse<'/webhooks/get'>>\n>\n\nexport type WebhooksGetOptions = never\n\nexport type WebhooksListParams = RouteRequestBody<'/webhooks/list'>\n\nexport type WebhooksListResponse = SetNonNullable<\n  Required<RouteResponse<'/webhooks/list'>>\n>\n\nexport type WebhooksListOptions = never\n","/*\n * Automatically generated by generate-routes.ts.\n * Do not edit this file or add other files to this directory.\n */\n\nimport type { RouteRequestBody, RouteResponse } from '@seamapi/types/connect'\nimport type { SetNonNullable } from 'type-fest'\n\nimport { warnOnInsecureuserIdentifierKey } from 'lib/seam/connect/auth.js'\nimport { type Client, createClient } from 'lib/seam/connect/client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from 'lib/seam/connect/options.js'\nimport {\n  limitToSeamHttpRequestOptions,\n  parseOptions,\n} from 'lib/seam/connect/parse-options.js'\n\nimport { SeamHttpClientSessions } from './client-sessions.js'\n\nexport class SeamHttpWorkspaces {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttpWorkspaces {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpWorkspaces(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttpWorkspaces {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttpWorkspaces(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttpWorkspaces {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttpWorkspaces(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttpWorkspaces> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttpWorkspaces.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpWorkspaces {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttpWorkspaces(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttpWorkspaces {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttpWorkspaces(constructorOptions)\n  }\n\n  async create(\n    body?: WorkspacesCreateBody,\n  ): Promise<WorkspacesCreateResponse['workspace']> {\n    const { data } = await this.client.request<WorkspacesCreateResponse>({\n      url: '/workspaces/create',\n      method: 'post',\n      data: body,\n    })\n\n    return data.workspace\n  }\n\n  async get(\n    body?: WorkspacesGetParams,\n  ): Promise<WorkspacesGetResponse['workspace']> {\n    const { data } = await this.client.request<WorkspacesGetResponse>({\n      url: '/workspaces/get',\n      method: 'post',\n      data: body,\n    })\n\n    return data.workspace\n  }\n\n  async list(\n    body?: WorkspacesListParams,\n  ): Promise<WorkspacesListResponse['workspaces']> {\n    const { data } = await this.client.request<WorkspacesListResponse>({\n      url: '/workspaces/list',\n      method: 'post',\n      data: body,\n    })\n\n    return data.workspaces\n  }\n\n  async resetSandbox(body?: WorkspacesResetSandboxBody): Promise<void> {\n    await this.client.request<WorkspacesResetSandboxResponse>({\n      url: '/workspaces/reset_sandbox',\n      method: 'post',\n      data: body,\n    })\n  }\n}\n\nexport type WorkspacesCreateBody = RouteRequestBody<'/workspaces/create'>\n\nexport type WorkspacesCreateResponse = SetNonNullable<\n  Required<RouteResponse<'/workspaces/create'>>\n>\n\nexport type WorkspacesCreateOptions = never\n\nexport type WorkspacesGetParams = RouteRequestBody<'/workspaces/get'>\n\nexport type WorkspacesGetResponse = SetNonNullable<\n  Required<RouteResponse<'/workspaces/get'>>\n>\n\nexport type WorkspacesGetOptions = never\n\nexport type WorkspacesListParams = RouteRequestBody<'/workspaces/list'>\n\nexport type WorkspacesListResponse = SetNonNullable<\n  Required<RouteResponse<'/workspaces/list'>>\n>\n\nexport type WorkspacesListOptions = never\n\nexport type WorkspacesResetSandboxBody =\n  RouteRequestBody<'/workspaces/reset_sandbox'>\n\nexport type WorkspacesResetSandboxResponse = SetNonNullable<\n  Required<RouteResponse<'/workspaces/reset_sandbox'>>\n>\n\nexport type WorkspacesResetSandboxOptions = never\n","import { warnOnInsecureuserIdentifierKey } from './auth.js'\nimport { type Client, createClient } from './client.js'\nimport {\n  isSeamHttpOptionsWithApiKey,\n  isSeamHttpOptionsWithClient,\n  isSeamHttpOptionsWithClientSessionToken,\n  isSeamHttpOptionsWithConsoleSessionToken,\n  isSeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpFromPublishableKeyOptions,\n  SeamHttpInvalidOptionsError,\n  type SeamHttpOptions,\n  type SeamHttpOptionsWithApiKey,\n  type SeamHttpOptionsWithClient,\n  type SeamHttpOptionsWithClientSessionToken,\n  type SeamHttpOptionsWithConsoleSessionToken,\n  type SeamHttpOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from './options.js'\nimport { limitToSeamHttpRequestOptions, parseOptions } from './parse-options.js'\nimport {\n  SeamHttpAccessCodes,\n  SeamHttpAcs,\n  SeamHttpActionAttempts,\n  SeamHttpClientSessions,\n  SeamHttpConnectedAccounts,\n  SeamHttpConnectWebviews,\n  SeamHttpDevices,\n  SeamHttpEvents,\n  SeamHttpLocks,\n  SeamHttpNetworks,\n  SeamHttpNoiseSensors,\n  SeamHttpPhones,\n  SeamHttpThermostats,\n  SeamHttpUserIdentities,\n  SeamHttpWebhooks,\n  SeamHttpWorkspaces,\n} from './routes/index.js'\n\nexport class SeamHttp {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(apiKeyOrOptions: string | SeamHttpOptions = {}) {\n    const options = parseOptions(apiKeyOrOptions)\n    this.client = 'client' in options ? options.client : createClient(options)\n    this.defaults = limitToSeamHttpRequestOptions(options)\n  }\n\n  static fromClient(\n    client: SeamHttpOptionsWithClient['client'],\n    options: Omit<SeamHttpOptionsWithClient, 'client'> = {},\n  ): SeamHttp {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing client')\n    }\n    return new SeamHttp(constructorOptions)\n  }\n\n  static fromApiKey(\n    apiKey: SeamHttpOptionsWithApiKey['apiKey'],\n    options: Omit<SeamHttpOptionsWithApiKey, 'apiKey'> = {},\n  ): SeamHttp {\n    const constructorOptions = { ...options, apiKey }\n    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing apiKey')\n    }\n    return new SeamHttp(constructorOptions)\n  }\n\n  static fromClientSessionToken(\n    clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'],\n    options: Omit<\n      SeamHttpOptionsWithClientSessionToken,\n      'clientSessionToken'\n    > = {},\n  ): SeamHttp {\n    const constructorOptions = { ...options, clientSessionToken }\n    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError('Missing clientSessionToken')\n    }\n    return new SeamHttp(constructorOptions)\n  }\n\n  static async fromPublishableKey(\n    publishableKey: string,\n    userIdentifierKey: string,\n    options: SeamHttpFromPublishableKeyOptions = {},\n  ): Promise<SeamHttp> {\n    warnOnInsecureuserIdentifierKey(userIdentifierKey)\n    const clientOptions = parseOptions({ ...options, publishableKey })\n    if (isSeamHttpOptionsWithClient(clientOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'The client option cannot be used with SeamHttp.fromPublishableKey',\n      )\n    }\n    const client = createClient(clientOptions)\n    const clientSessions = SeamHttpClientSessions.fromClient(client)\n    const { token } = await clientSessions.getOrCreate({\n      user_identifier_key: userIdentifierKey,\n    })\n    return SeamHttp.fromClientSessionToken(token, options)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'],\n    workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithConsoleSessionToken,\n      'consoleSessionToken' | 'workspaceId'\n    > = {},\n  ): SeamHttp {\n    const constructorOptions = { ...options, consoleSessionToken, workspaceId }\n    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing consoleSessionToken or workspaceId',\n      )\n    }\n    return new SeamHttp(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'],\n    workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'],\n    options: Omit<\n      SeamHttpOptionsWithPersonalAccessToken,\n      'personalAccessToken' | 'workspaceId'\n    > = {},\n  ): SeamHttp {\n    const constructorOptions = { ...options, personalAccessToken, workspaceId }\n    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {\n      throw new SeamHttpInvalidOptionsError(\n        'Missing personalAccessToken or workspaceId',\n      )\n    }\n    return new SeamHttp(constructorOptions)\n  }\n\n  get accessCodes(): SeamHttpAccessCodes {\n    return SeamHttpAccessCodes.fromClient(this.client, this.defaults)\n  }\n\n  get acs(): SeamHttpAcs {\n    return SeamHttpAcs.fromClient(this.client, this.defaults)\n  }\n\n  get actionAttempts(): SeamHttpActionAttempts {\n    return SeamHttpActionAttempts.fromClient(this.client, this.defaults)\n  }\n\n  get clientSessions(): SeamHttpClientSessions {\n    return SeamHttpClientSessions.fromClient(this.client, this.defaults)\n  }\n\n  get connectedAccounts(): SeamHttpConnectedAccounts {\n    return SeamHttpConnectedAccounts.fromClient(this.client, this.defaults)\n  }\n\n  get connectWebviews(): SeamHttpConnectWebviews {\n    return SeamHttpConnectWebviews.fromClient(this.client, this.defaults)\n  }\n\n  get devices(): SeamHttpDevices {\n    return SeamHttpDevices.fromClient(this.client, this.defaults)\n  }\n\n  get events(): SeamHttpEvents {\n    return SeamHttpEvents.fromClient(this.client, this.defaults)\n  }\n\n  get locks(): SeamHttpLocks {\n    return SeamHttpLocks.fromClient(this.client, this.defaults)\n  }\n\n  get networks(): SeamHttpNetworks {\n    return SeamHttpNetworks.fromClient(this.client, this.defaults)\n  }\n\n  get noiseSensors(): SeamHttpNoiseSensors {\n    return SeamHttpNoiseSensors.fromClient(this.client, this.defaults)\n  }\n\n  get phones(): SeamHttpPhones {\n    return SeamHttpPhones.fromClient(this.client, this.defaults)\n  }\n\n  get thermostats(): SeamHttpThermostats {\n    return SeamHttpThermostats.fromClient(this.client, this.defaults)\n  }\n\n  get userIdentities(): SeamHttpUserIdentities {\n    return SeamHttpUserIdentities.fromClient(this.client, this.defaults)\n  }\n\n  get webhooks(): SeamHttpWebhooks {\n    return SeamHttpWebhooks.fromClient(this.client, this.defaults)\n  }\n\n  get workspaces(): Omit<SeamHttpWorkspaces, 'create'> {\n    return SeamHttpWorkspaces.fromClient(this.client, this.defaults)\n  }\n}\n","import { type Client, createClient } from './client.js'\nimport {\n  isSeamHttpMultiWorkspaceOptionsWithClient,\n  isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken,\n  isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken,\n  SeamHttpMultiWorkspaceInvalidOptionsError,\n  type SeamHttpMultiWorkspaceOptions,\n  type SeamHttpMultiWorkspaceOptionsWithClient,\n  type SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken,\n  type SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken,\n  type SeamHttpRequestOptions,\n} from './options.js'\nimport { limitToSeamHttpRequestOptions, parseOptions } from './parse-options.js'\nimport { SeamHttpWorkspaces } from './routes/index.js'\n\nexport class SeamHttpMultiWorkspace {\n  client: Client\n  readonly defaults: Required<SeamHttpRequestOptions>\n\n  constructor(options: SeamHttpMultiWorkspaceOptions) {\n    const opts = parseOptions(options)\n    this.client = 'client' in opts ? opts.client : createClient(opts)\n    this.defaults = limitToSeamHttpRequestOptions(opts)\n  }\n\n  static fromClient(\n    client: SeamHttpMultiWorkspaceOptionsWithClient['client'],\n    options: Omit<SeamHttpMultiWorkspaceOptionsWithClient, 'client'> = {},\n  ): SeamHttpMultiWorkspace {\n    const constructorOptions = { ...options, client }\n    if (!isSeamHttpMultiWorkspaceOptionsWithClient(constructorOptions)) {\n      throw new SeamHttpMultiWorkspaceInvalidOptionsError('Missing client')\n    }\n    return new SeamHttpMultiWorkspace(constructorOptions)\n  }\n\n  static fromConsoleSessionToken(\n    consoleSessionToken: SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken['consoleSessionToken'],\n    options: Omit<\n      SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken,\n      'consoleSessionToken'\n    > = {},\n  ): SeamHttpMultiWorkspace {\n    const constructorOptions = { ...options, consoleSessionToken }\n    if (\n      !isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(\n        constructorOptions,\n      )\n    ) {\n      throw new SeamHttpMultiWorkspaceInvalidOptionsError(\n        'Missing consoleSessionToken',\n      )\n    }\n    return new SeamHttpMultiWorkspace(constructorOptions)\n  }\n\n  static fromPersonalAccessToken(\n    personalAccessToken: SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken['personalAccessToken'],\n    options: Omit<\n      SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken,\n      'personalAccessToken'\n    > = {},\n  ): SeamHttpMultiWorkspace {\n    const constructorOptions = { ...options, personalAccessToken }\n    if (\n      !isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(\n        constructorOptions,\n      )\n    ) {\n      throw new SeamHttpMultiWorkspaceInvalidOptionsError(\n        'Missing personalAccessToken',\n      )\n    }\n    return new SeamHttpMultiWorkspace(constructorOptions)\n  }\n\n  get workspaces(): Pick<SeamHttpWorkspaces, 'create' | 'list'> {\n    return SeamHttpWorkspaces.fromClient(this.client, this.defaults)\n  }\n}\n","export * from './lib/seam/connect/index.js'\nexport * from '@seamapi/url-search-params-serializer'\n"]}