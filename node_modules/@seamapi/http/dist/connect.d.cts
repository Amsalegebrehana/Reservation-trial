import { RouteRequestBody, RouteResponse, RouteRequestParams, openapi } from '@seamapi/types/connect';
import { AxiosInstance, AxiosRequestConfig } from 'axios';
import { AxiosRetry } from 'axios-retry';
import { SetNonNullable } from 'type-fest';
export * from '@seamapi/url-search-params-serializer';

type Client = AxiosInstance;
interface ClientOptions {
    axiosOptions?: AxiosRequestConfig;
    axiosRetryOptions?: AxiosRetryConfig;
}
type AxiosRetryConfig = Parameters<AxiosRetry>[1];

interface ActionAttempt {
    action_attempt_id: string;
    status: 'pending' | 'error' | 'success';
}
type FailedActionAttempt<T extends ActionAttempt> = T & {
    status: 'error';
    error: {
        type: string;
        message: string;
    };
};

declare class SeamHttpAccessCodesUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAccessCodesUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAccessCodesUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAccessCodesUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAccessCodesUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAccessCodesUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAccessCodesUnmanaged;
    convertToManaged(body?: AccessCodesUnmanagedConvertToManagedBody): Promise<void>;
    delete(body?: AccessCodesUnmanagedDeleteBody): Promise<void>;
    get(body?: AccessCodesUnmanagedGetParams): Promise<AccessCodesUnmanagedGetResponse['access_code']>;
    list(body?: AccessCodesUnmanagedListParams): Promise<AccessCodesUnmanagedListResponse['access_codes']>;
    update(body?: AccessCodesUnmanagedUpdateBody): Promise<void>;
}
type AccessCodesUnmanagedConvertToManagedBody = RouteRequestBody<'/access_codes/unmanaged/convert_to_managed'>;
type AccessCodesUnmanagedConvertToManagedResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/convert_to_managed'>>>;
type AccessCodesUnmanagedConvertToManagedOptions = never;
type AccessCodesUnmanagedDeleteBody = RouteRequestBody<'/access_codes/unmanaged/delete'>;
type AccessCodesUnmanagedDeleteResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/delete'>>>;
type AccessCodesUnmanagedDeleteOptions = never;
type AccessCodesUnmanagedGetParams = RouteRequestBody<'/access_codes/unmanaged/get'>;
type AccessCodesUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/get'>>>;
type AccessCodesUnmanagedGetOptions = never;
type AccessCodesUnmanagedListParams = RouteRequestBody<'/access_codes/unmanaged/list'>;
type AccessCodesUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/list'>>>;
type AccessCodesUnmanagedListOptions = never;
type AccessCodesUnmanagedUpdateBody = RouteRequestBody<'/access_codes/unmanaged/update'>;
type AccessCodesUnmanagedUpdateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/unmanaged/update'>>>;
type AccessCodesUnmanagedUpdateOptions = never;

declare class SeamHttpAccessCodes {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAccessCodes;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAccessCodes;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAccessCodes;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAccessCodes>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAccessCodes;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAccessCodes;
    get unmanaged(): SeamHttpAccessCodesUnmanaged;
    create(body?: AccessCodesCreateBody): Promise<AccessCodesCreateResponse['access_code']>;
    createMultiple(body?: AccessCodesCreateMultipleBody): Promise<AccessCodesCreateMultipleResponse['access_codes']>;
    delete(body?: AccessCodesDeleteBody): Promise<void>;
    generateCode(body?: AccessCodesGenerateCodeBody): Promise<AccessCodesGenerateCodeResponse['generated_code']>;
    get(body?: AccessCodesGetParams): Promise<AccessCodesGetResponse['access_code']>;
    list(body?: AccessCodesListParams): Promise<AccessCodesListResponse['access_codes']>;
    pullBackupAccessCode(body?: AccessCodesPullBackupAccessCodeBody): Promise<AccessCodesPullBackupAccessCodeResponse['backup_access_code']>;
    update(body?: AccessCodesUpdateBody): Promise<void>;
}
type AccessCodesCreateBody = RouteRequestBody<'/access_codes/create'>;
type AccessCodesCreateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/create'>>>;
type AccessCodesCreateOptions = never;
type AccessCodesCreateMultipleBody = RouteRequestBody<'/access_codes/create_multiple'>;
type AccessCodesCreateMultipleResponse = SetNonNullable<Required<RouteResponse<'/access_codes/create_multiple'>>>;
type AccessCodesCreateMultipleOptions = never;
type AccessCodesDeleteBody = RouteRequestBody<'/access_codes/delete'>;
type AccessCodesDeleteResponse = SetNonNullable<Required<RouteResponse<'/access_codes/delete'>>>;
type AccessCodesDeleteOptions = never;
type AccessCodesGenerateCodeBody = RouteRequestBody<'/access_codes/generate_code'>;
type AccessCodesGenerateCodeResponse = SetNonNullable<Required<RouteResponse<'/access_codes/generate_code'>>>;
type AccessCodesGenerateCodeOptions = never;
type AccessCodesGetParams = RouteRequestBody<'/access_codes/get'>;
type AccessCodesGetResponse = SetNonNullable<Required<RouteResponse<'/access_codes/get'>>>;
type AccessCodesGetOptions = never;
type AccessCodesListParams = RouteRequestBody<'/access_codes/list'>;
type AccessCodesListResponse = SetNonNullable<Required<RouteResponse<'/access_codes/list'>>>;
type AccessCodesListOptions = never;
type AccessCodesPullBackupAccessCodeBody = RouteRequestBody<'/access_codes/pull_backup_access_code'>;
type AccessCodesPullBackupAccessCodeResponse = SetNonNullable<Required<RouteResponse<'/access_codes/pull_backup_access_code'>>>;
type AccessCodesPullBackupAccessCodeOptions = never;
type AccessCodesUpdateBody = RouteRequestBody<'/access_codes/update'>;
type AccessCodesUpdateResponse = SetNonNullable<Required<RouteResponse<'/access_codes/update'>>>;
type AccessCodesUpdateOptions = never;

declare class SeamHttpAcsAccessGroups {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsAccessGroups;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsAccessGroups;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsAccessGroups;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsAccessGroups>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsAccessGroups;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsAccessGroups;
    addUser(body?: AcsAccessGroupsAddUserBody): Promise<void>;
    get(body?: AcsAccessGroupsGetParams): Promise<AcsAccessGroupsGetResponse['acs_access_group']>;
    list(body?: AcsAccessGroupsListParams): Promise<AcsAccessGroupsListResponse['acs_access_groups']>;
    listUsers(body?: AcsAccessGroupsListUsersParams): Promise<AcsAccessGroupsListUsersResponse['acs_users']>;
    removeUser(body?: AcsAccessGroupsRemoveUserBody): Promise<void>;
}
type AcsAccessGroupsAddUserBody = RouteRequestBody<'/acs/access_groups/add_user'>;
type AcsAccessGroupsAddUserResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/add_user'>>>;
type AcsAccessGroupsAddUserOptions = never;
type AcsAccessGroupsGetParams = RouteRequestBody<'/acs/access_groups/get'>;
type AcsAccessGroupsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/get'>>>;
type AcsAccessGroupsGetOptions = never;
type AcsAccessGroupsListParams = RouteRequestBody<'/acs/access_groups/list'>;
type AcsAccessGroupsListResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/list'>>>;
type AcsAccessGroupsListOptions = never;
type AcsAccessGroupsListUsersParams = RouteRequestBody<'/acs/access_groups/list_users'>;
type AcsAccessGroupsListUsersResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/list_users'>>>;
type AcsAccessGroupsListUsersOptions = never;
type AcsAccessGroupsRemoveUserBody = RouteRequestBody<'/acs/access_groups/remove_user'>;
type AcsAccessGroupsRemoveUserResponse = SetNonNullable<Required<RouteResponse<'/acs/access_groups/remove_user'>>>;
type AcsAccessGroupsRemoveUserOptions = never;

declare class SeamHttpAcsCredentialPools {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentialPools;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentialPools;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentialPools;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentialPools>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentialPools;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentialPools;
    list(body?: AcsCredentialPoolsListParams): Promise<AcsCredentialPoolsListResponse['acs_credential_pools']>;
}
type AcsCredentialPoolsListParams = RouteRequestBody<'/acs/credential_pools/list'>;
type AcsCredentialPoolsListResponse = SetNonNullable<Required<RouteResponse<'/acs/credential_pools/list'>>>;
type AcsCredentialPoolsListOptions = never;

declare class SeamHttpAcsCredentialProvisioningAutomations {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentialProvisioningAutomations>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentialProvisioningAutomations;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentialProvisioningAutomations;
    launch(body?: AcsCredentialProvisioningAutomationsLaunchBody): Promise<AcsCredentialProvisioningAutomationsLaunchResponse['acs_credential_provisioning_automation']>;
}
type AcsCredentialProvisioningAutomationsLaunchBody = RouteRequestBody<'/acs/credential_provisioning_automations/launch'>;
type AcsCredentialProvisioningAutomationsLaunchResponse = SetNonNullable<Required<RouteResponse<'/acs/credential_provisioning_automations/launch'>>>;
type AcsCredentialProvisioningAutomationsLaunchOptions = never;

declare class SeamHttpAcsCredentials {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsCredentials;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsCredentials;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsCredentials;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsCredentials>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsCredentials;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsCredentials;
    assign(body?: AcsCredentialsAssignBody): Promise<AcsCredentialsAssignResponse['acs_credential']>;
    create(body?: AcsCredentialsCreateBody): Promise<AcsCredentialsCreateResponse['acs_credential']>;
    delete(body?: AcsCredentialsDeleteBody): Promise<void>;
    get(body?: AcsCredentialsGetParams): Promise<AcsCredentialsGetResponse['acs_credential']>;
    list(body?: AcsCredentialsListParams): Promise<AcsCredentialsListResponse['acs_credentials']>;
    unassign(body?: AcsCredentialsUnassignBody): Promise<AcsCredentialsUnassignResponse['acs_credential']>;
    update(body?: AcsCredentialsUpdateBody): Promise<AcsCredentialsUpdateResponse['acs_credential']>;
}
type AcsCredentialsAssignBody = RouteRequestBody<'/acs/credentials/assign'>;
type AcsCredentialsAssignResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/assign'>>>;
type AcsCredentialsAssignOptions = never;
type AcsCredentialsCreateBody = RouteRequestBody<'/acs/credentials/create'>;
type AcsCredentialsCreateResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/create'>>>;
type AcsCredentialsCreateOptions = never;
type AcsCredentialsDeleteBody = RouteRequestBody<'/acs/credentials/delete'>;
type AcsCredentialsDeleteResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/delete'>>>;
type AcsCredentialsDeleteOptions = never;
type AcsCredentialsGetParams = RouteRequestBody<'/acs/credentials/get'>;
type AcsCredentialsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/get'>>>;
type AcsCredentialsGetOptions = never;
type AcsCredentialsListParams = RouteRequestBody<'/acs/credentials/list'>;
type AcsCredentialsListResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/list'>>>;
type AcsCredentialsListOptions = never;
type AcsCredentialsUnassignBody = RouteRequestBody<'/acs/credentials/unassign'>;
type AcsCredentialsUnassignResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/unassign'>>>;
type AcsCredentialsUnassignOptions = never;
type AcsCredentialsUpdateBody = RouteRequestBody<'/acs/credentials/update'>;
type AcsCredentialsUpdateResponse = SetNonNullable<Required<RouteResponse<'/acs/credentials/update'>>>;
type AcsCredentialsUpdateOptions = never;

declare class SeamHttpAcsEntrances {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsEntrances;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsEntrances;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsEntrances;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsEntrances>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsEntrances;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsEntrances;
    get(body?: AcsEntrancesGetParams): Promise<AcsEntrancesGetResponse['acs_entrance']>;
    grantAccess(body?: AcsEntrancesGrantAccessBody): Promise<void>;
    list(body?: AcsEntrancesListParams): Promise<AcsEntrancesListResponse['acs_entrances']>;
}
type AcsEntrancesGetParams = RouteRequestBody<'/acs/entrances/get'>;
type AcsEntrancesGetResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/get'>>>;
type AcsEntrancesGetOptions = never;
type AcsEntrancesGrantAccessBody = RouteRequestBody<'/acs/entrances/grant_access'>;
type AcsEntrancesGrantAccessResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/grant_access'>>>;
type AcsEntrancesGrantAccessOptions = never;
type AcsEntrancesListParams = RouteRequestBody<'/acs/entrances/list'>;
type AcsEntrancesListResponse = SetNonNullable<Required<RouteResponse<'/acs/entrances/list'>>>;
type AcsEntrancesListOptions = never;

declare class SeamHttpAcsSystems {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsSystems;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsSystems;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsSystems;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsSystems>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsSystems;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsSystems;
    get(body?: AcsSystemsGetParams): Promise<AcsSystemsGetResponse['acs_system']>;
    list(body?: AcsSystemsListParams): Promise<AcsSystemsListResponse['acs_systems']>;
}
type AcsSystemsGetParams = RouteRequestBody<'/acs/systems/get'>;
type AcsSystemsGetResponse = SetNonNullable<Required<RouteResponse<'/acs/systems/get'>>>;
type AcsSystemsGetOptions = never;
type AcsSystemsListParams = RouteRequestBody<'/acs/systems/list'>;
type AcsSystemsListResponse = SetNonNullable<Required<RouteResponse<'/acs/systems/list'>>>;
type AcsSystemsListOptions = never;

declare class SeamHttpAcsUsers {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcsUsers;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcsUsers;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcsUsers;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcsUsers>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcsUsers;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcsUsers;
    addToAccessGroup(body?: AcsUsersAddToAccessGroupBody): Promise<void>;
    create(body?: AcsUsersCreateBody): Promise<AcsUsersCreateResponse['acs_user']>;
    delete(body?: AcsUsersDeleteBody): Promise<void>;
    get(body?: AcsUsersGetParams): Promise<AcsUsersGetResponse['acs_user']>;
    list(body?: AcsUsersListParams): Promise<AcsUsersListResponse['acs_users']>;
    listAccessibleEntrances(body?: AcsUsersListAccessibleEntrancesParams): Promise<AcsUsersListAccessibleEntrancesResponse['acs_entrances']>;
    removeFromAccessGroup(body?: AcsUsersRemoveFromAccessGroupBody): Promise<void>;
    suspend(body?: AcsUsersSuspendBody): Promise<void>;
    unsuspend(body?: AcsUsersUnsuspendBody): Promise<void>;
    update(body?: AcsUsersUpdateBody): Promise<void>;
}
type AcsUsersAddToAccessGroupBody = RouteRequestBody<'/acs/users/add_to_access_group'>;
type AcsUsersAddToAccessGroupResponse = SetNonNullable<Required<RouteResponse<'/acs/users/add_to_access_group'>>>;
type AcsUsersAddToAccessGroupOptions = never;
type AcsUsersCreateBody = RouteRequestBody<'/acs/users/create'>;
type AcsUsersCreateResponse = SetNonNullable<Required<RouteResponse<'/acs/users/create'>>>;
type AcsUsersCreateOptions = never;
type AcsUsersDeleteBody = RouteRequestBody<'/acs/users/delete'>;
type AcsUsersDeleteResponse = SetNonNullable<Required<RouteResponse<'/acs/users/delete'>>>;
type AcsUsersDeleteOptions = never;
type AcsUsersGetParams = RouteRequestBody<'/acs/users/get'>;
type AcsUsersGetResponse = SetNonNullable<Required<RouteResponse<'/acs/users/get'>>>;
type AcsUsersGetOptions = never;
type AcsUsersListParams = RouteRequestBody<'/acs/users/list'>;
type AcsUsersListResponse = SetNonNullable<Required<RouteResponse<'/acs/users/list'>>>;
type AcsUsersListOptions = never;
type AcsUsersListAccessibleEntrancesParams = RouteRequestBody<'/acs/users/list_accessible_entrances'>;
type AcsUsersListAccessibleEntrancesResponse = SetNonNullable<Required<RouteResponse<'/acs/users/list_accessible_entrances'>>>;
type AcsUsersListAccessibleEntrancesOptions = never;
type AcsUsersRemoveFromAccessGroupBody = RouteRequestBody<'/acs/users/remove_from_access_group'>;
type AcsUsersRemoveFromAccessGroupResponse = SetNonNullable<Required<RouteResponse<'/acs/users/remove_from_access_group'>>>;
type AcsUsersRemoveFromAccessGroupOptions = never;
type AcsUsersSuspendBody = RouteRequestBody<'/acs/users/suspend'>;
type AcsUsersSuspendResponse = SetNonNullable<Required<RouteResponse<'/acs/users/suspend'>>>;
type AcsUsersSuspendOptions = never;
type AcsUsersUnsuspendBody = RouteRequestBody<'/acs/users/unsuspend'>;
type AcsUsersUnsuspendResponse = SetNonNullable<Required<RouteResponse<'/acs/users/unsuspend'>>>;
type AcsUsersUnsuspendOptions = never;
type AcsUsersUpdateBody = RouteRequestBody<'/acs/users/update'>;
type AcsUsersUpdateResponse = SetNonNullable<Required<RouteResponse<'/acs/users/update'>>>;
type AcsUsersUpdateOptions = never;

declare class SeamHttpAcs {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpAcs;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpAcs;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpAcs;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpAcs>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpAcs;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpAcs;
    get accessGroups(): SeamHttpAcsAccessGroups;
    get credentialPools(): SeamHttpAcsCredentialPools;
    get credentialProvisioningAutomations(): SeamHttpAcsCredentialProvisioningAutomations;
    get credentials(): SeamHttpAcsCredentials;
    get entrances(): SeamHttpAcsEntrances;
    get systems(): SeamHttpAcsSystems;
    get users(): SeamHttpAcsUsers;
}

declare class SeamHttpActionAttempts {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpActionAttempts;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpActionAttempts;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpActionAttempts;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpActionAttempts>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpActionAttempts;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpActionAttempts;
    get(body?: ActionAttemptsGetParams, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): Promise<ActionAttemptsGetResponse['action_attempt']>;
    list(body?: ActionAttemptsListParams): Promise<ActionAttemptsListResponse['action_attempts']>;
}
type ActionAttemptsGetParams = RouteRequestBody<'/action_attempts/get'>;
type ActionAttemptsGetResponse = SetNonNullable<Required<RouteResponse<'/action_attempts/get'>>>;
type ActionAttemptsGetOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type ActionAttemptsListParams = RouteRequestBody<'/action_attempts/list'>;
type ActionAttemptsListResponse = SetNonNullable<Required<RouteResponse<'/action_attempts/list'>>>;
type ActionAttemptsListOptions = never;

declare class SeamHttpClientSessions {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpClientSessions;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpClientSessions;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpClientSessions;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpClientSessions>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpClientSessions;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpClientSessions;
    create(body?: ClientSessionsCreateBody): Promise<ClientSessionsCreateResponse['client_session']>;
    delete(body?: ClientSessionsDeleteBody): Promise<void>;
    get(body?: ClientSessionsGetParams): Promise<ClientSessionsGetResponse['client_session']>;
    getOrCreate(body?: ClientSessionsGetOrCreateBody): Promise<ClientSessionsGetOrCreateResponse['client_session']>;
    grantAccess(body?: ClientSessionsGrantAccessBody): Promise<ClientSessionsGrantAccessResponse['client_session']>;
    list(body?: ClientSessionsListParams): Promise<ClientSessionsListResponse['client_sessions']>;
    revoke(body?: ClientSessionsRevokeBody): Promise<void>;
}
type ClientSessionsCreateBody = RouteRequestBody<'/client_sessions/create'>;
type ClientSessionsCreateResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/create'>>>;
type ClientSessionsCreateOptions = never;
type ClientSessionsDeleteBody = RouteRequestBody<'/client_sessions/delete'>;
type ClientSessionsDeleteResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/delete'>>>;
type ClientSessionsDeleteOptions = never;
type ClientSessionsGetParams = RouteRequestBody<'/client_sessions/get'>;
type ClientSessionsGetResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/get'>>>;
type ClientSessionsGetOptions = never;
type ClientSessionsGetOrCreateBody = RouteRequestBody<'/client_sessions/get_or_create'>;
type ClientSessionsGetOrCreateResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/get_or_create'>>>;
type ClientSessionsGetOrCreateOptions = never;
type ClientSessionsGrantAccessBody = RouteRequestBody<'/client_sessions/grant_access'>;
type ClientSessionsGrantAccessResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/grant_access'>>>;
type ClientSessionsGrantAccessOptions = never;
type ClientSessionsListParams = RouteRequestBody<'/client_sessions/list'>;
type ClientSessionsListResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/list'>>>;
type ClientSessionsListOptions = never;
type ClientSessionsRevokeBody = RouteRequestBody<'/client_sessions/revoke'>;
type ClientSessionsRevokeResponse = SetNonNullable<Required<RouteResponse<'/client_sessions/revoke'>>>;
type ClientSessionsRevokeOptions = never;

declare class SeamHttpConnectWebviews {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpConnectWebviews;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpConnectWebviews;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpConnectWebviews;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpConnectWebviews>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpConnectWebviews;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpConnectWebviews;
    create(body?: ConnectWebviewsCreateBody): Promise<ConnectWebviewsCreateResponse['connect_webview']>;
    delete(body?: ConnectWebviewsDeleteBody): Promise<void>;
    get(body?: ConnectWebviewsGetParams): Promise<ConnectWebviewsGetResponse['connect_webview']>;
    list(body?: ConnectWebviewsListParams): Promise<ConnectWebviewsListResponse['connect_webviews']>;
    view(params?: ConnectWebviewsViewParams): Promise<void>;
}
type ConnectWebviewsCreateBody = RouteRequestBody<'/connect_webviews/create'>;
type ConnectWebviewsCreateResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/create'>>>;
type ConnectWebviewsCreateOptions = never;
type ConnectWebviewsDeleteBody = RouteRequestBody<'/connect_webviews/delete'>;
type ConnectWebviewsDeleteResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/delete'>>>;
type ConnectWebviewsDeleteOptions = never;
type ConnectWebviewsGetParams = RouteRequestBody<'/connect_webviews/get'>;
type ConnectWebviewsGetResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/get'>>>;
type ConnectWebviewsGetOptions = never;
type ConnectWebviewsListParams = RouteRequestBody<'/connect_webviews/list'>;
type ConnectWebviewsListResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/list'>>>;
type ConnectWebviewsListOptions = never;
type ConnectWebviewsViewParams = RouteRequestParams<'/connect_webviews/view'>;
type ConnectWebviewsViewResponse = SetNonNullable<Required<RouteResponse<'/connect_webviews/view'>>>;
type ConnectWebviewsViewOptions = never;

declare class SeamHttpConnectedAccounts {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpConnectedAccounts;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpConnectedAccounts;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpConnectedAccounts;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpConnectedAccounts>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpConnectedAccounts;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpConnectedAccounts;
    delete(body?: ConnectedAccountsDeleteBody): Promise<void>;
    get(body?: ConnectedAccountsGetParams): Promise<ConnectedAccountsGetResponse['connected_account']>;
    list(body?: ConnectedAccountsListParams): Promise<ConnectedAccountsListResponse['connected_accounts']>;
    update(body?: ConnectedAccountsUpdateBody): Promise<ConnectedAccountsUpdateResponse['connected_account']>;
}
type ConnectedAccountsDeleteBody = RouteRequestBody<'/connected_accounts/delete'>;
type ConnectedAccountsDeleteResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/delete'>>>;
type ConnectedAccountsDeleteOptions = never;
type ConnectedAccountsGetParams = RouteRequestBody<'/connected_accounts/get'>;
type ConnectedAccountsGetResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/get'>>>;
type ConnectedAccountsGetOptions = never;
type ConnectedAccountsListParams = RouteRequestBody<'/connected_accounts/list'>;
type ConnectedAccountsListResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/list'>>>;
type ConnectedAccountsListOptions = never;
type ConnectedAccountsUpdateBody = RouteRequestBody<'/connected_accounts/update'>;
type ConnectedAccountsUpdateResponse = SetNonNullable<Required<RouteResponse<'/connected_accounts/update'>>>;
type ConnectedAccountsUpdateOptions = never;

declare class SeamHttpDevicesUnmanaged {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpDevicesUnmanaged;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpDevicesUnmanaged;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpDevicesUnmanaged;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpDevicesUnmanaged>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpDevicesUnmanaged;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpDevicesUnmanaged;
    get(body?: DevicesUnmanagedGetParams): Promise<DevicesUnmanagedGetResponse['device']>;
    list(body?: DevicesUnmanagedListParams): Promise<DevicesUnmanagedListResponse['devices']>;
    update(body?: DevicesUnmanagedUpdateBody): Promise<void>;
}
type DevicesUnmanagedGetParams = RouteRequestBody<'/devices/unmanaged/get'>;
type DevicesUnmanagedGetResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/get'>>>;
type DevicesUnmanagedGetOptions = never;
type DevicesUnmanagedListParams = RouteRequestBody<'/devices/unmanaged/list'>;
type DevicesUnmanagedListResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/list'>>>;
type DevicesUnmanagedListOptions = never;
type DevicesUnmanagedUpdateBody = RouteRequestBody<'/devices/unmanaged/update'>;
type DevicesUnmanagedUpdateResponse = SetNonNullable<Required<RouteResponse<'/devices/unmanaged/update'>>>;
type DevicesUnmanagedUpdateOptions = never;

declare class SeamHttpDevices {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpDevices;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpDevices;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpDevices;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpDevices>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpDevices;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpDevices;
    get unmanaged(): SeamHttpDevicesUnmanaged;
    delete(body?: DevicesDeleteBody): Promise<void>;
    get(body?: DevicesGetParams): Promise<DevicesGetResponse['device']>;
    list(body?: DevicesListParams): Promise<DevicesListResponse['devices']>;
    listDeviceProviders(body?: DevicesListDeviceProvidersParams): Promise<DevicesListDeviceProvidersResponse['device_providers']>;
    update(body?: DevicesUpdateBody): Promise<void>;
}
type DevicesDeleteBody = RouteRequestBody<'/devices/delete'>;
type DevicesDeleteResponse = SetNonNullable<Required<RouteResponse<'/devices/delete'>>>;
type DevicesDeleteOptions = never;
type DevicesGetParams = RouteRequestBody<'/devices/get'>;
type DevicesGetResponse = SetNonNullable<Required<RouteResponse<'/devices/get'>>>;
type DevicesGetOptions = never;
type DevicesListParams = RouteRequestBody<'/devices/list'>;
type DevicesListResponse = SetNonNullable<Required<RouteResponse<'/devices/list'>>>;
type DevicesListOptions = never;
type DevicesListDeviceProvidersParams = RouteRequestBody<'/devices/list_device_providers'>;
type DevicesListDeviceProvidersResponse = SetNonNullable<Required<RouteResponse<'/devices/list_device_providers'>>>;
type DevicesListDeviceProvidersOptions = never;
type DevicesUpdateBody = RouteRequestBody<'/devices/update'>;
type DevicesUpdateResponse = SetNonNullable<Required<RouteResponse<'/devices/update'>>>;
type DevicesUpdateOptions = never;

declare class SeamHttpEvents {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpEvents;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpEvents;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpEvents;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpEvents>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpEvents;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpEvents;
    get(body?: EventsGetParams): Promise<EventsGetResponse['event']>;
    list(body?: EventsListParams): Promise<EventsListResponse['events']>;
}
type EventsGetParams = RouteRequestBody<'/events/get'>;
type EventsGetResponse = SetNonNullable<Required<RouteResponse<'/events/get'>>>;
type EventsGetOptions = never;
type EventsListParams = RouteRequestBody<'/events/list'>;
type EventsListResponse = SetNonNullable<Required<RouteResponse<'/events/list'>>>;
type EventsListOptions = never;

declare class SeamHttpLocks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpLocks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpLocks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpLocks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpLocks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpLocks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpLocks;
    get(body?: LocksGetParams): Promise<LocksGetResponse['device']>;
    list(body?: LocksListParams): Promise<LocksListResponse['devices']>;
    lockDoor(body?: LocksLockDoorBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): Promise<LocksLockDoorResponse['action_attempt']>;
    unlockDoor(body?: LocksUnlockDoorBody, options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>): Promise<LocksUnlockDoorResponse['action_attempt']>;
}
type LocksGetParams = RouteRequestBody<'/locks/get'>;
type LocksGetResponse = SetNonNullable<Required<RouteResponse<'/locks/get'>>>;
type LocksGetOptions = never;
type LocksListParams = RouteRequestBody<'/locks/list'>;
type LocksListResponse = SetNonNullable<Required<RouteResponse<'/locks/list'>>>;
type LocksListOptions = never;
type LocksLockDoorBody = RouteRequestBody<'/locks/lock_door'>;
type LocksLockDoorResponse = SetNonNullable<Required<RouteResponse<'/locks/lock_door'>>>;
type LocksLockDoorOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
type LocksUnlockDoorBody = RouteRequestBody<'/locks/unlock_door'>;
type LocksUnlockDoorResponse = SetNonNullable<Required<RouteResponse<'/locks/unlock_door'>>>;
type LocksUnlockDoorOptions = Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;

declare class SeamHttpNetworks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNetworks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNetworks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNetworks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNetworks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNetworks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNetworks;
    get(body?: NetworksGetParams): Promise<NetworksGetResponse['network']>;
    list(body?: NetworksListParams): Promise<NetworksListResponse['networks']>;
}
type NetworksGetParams = RouteRequestBody<'/networks/get'>;
type NetworksGetResponse = SetNonNullable<Required<RouteResponse<'/networks/get'>>>;
type NetworksGetOptions = never;
type NetworksListParams = RouteRequestBody<'/networks/list'>;
type NetworksListResponse = SetNonNullable<Required<RouteResponse<'/networks/list'>>>;
type NetworksListOptions = never;

declare class SeamHttpNoiseSensorsNoiseThresholds {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNoiseSensorsNoiseThresholds>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNoiseSensorsNoiseThresholds;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNoiseSensorsNoiseThresholds;
    create(body?: NoiseSensorsNoiseThresholdsCreateBody): Promise<NoiseSensorsNoiseThresholdsCreateResponse['noise_threshold']>;
    delete(body?: NoiseSensorsNoiseThresholdsDeleteBody): Promise<void>;
    get(body?: NoiseSensorsNoiseThresholdsGetParams): Promise<NoiseSensorsNoiseThresholdsGetResponse['noise_threshold']>;
    list(body?: NoiseSensorsNoiseThresholdsListParams): Promise<NoiseSensorsNoiseThresholdsListResponse['noise_thresholds']>;
    update(body?: NoiseSensorsNoiseThresholdsUpdateBody): Promise<void>;
}
type NoiseSensorsNoiseThresholdsCreateBody = RouteRequestBody<'/noise_sensors/noise_thresholds/create'>;
type NoiseSensorsNoiseThresholdsCreateResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/create'>>>;
type NoiseSensorsNoiseThresholdsCreateOptions = never;
type NoiseSensorsNoiseThresholdsDeleteBody = RouteRequestBody<'/noise_sensors/noise_thresholds/delete'>;
type NoiseSensorsNoiseThresholdsDeleteResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/delete'>>>;
type NoiseSensorsNoiseThresholdsDeleteOptions = never;
type NoiseSensorsNoiseThresholdsGetParams = RouteRequestBody<'/noise_sensors/noise_thresholds/get'>;
type NoiseSensorsNoiseThresholdsGetResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/get'>>>;
type NoiseSensorsNoiseThresholdsGetOptions = never;
type NoiseSensorsNoiseThresholdsListParams = RouteRequestBody<'/noise_sensors/noise_thresholds/list'>;
type NoiseSensorsNoiseThresholdsListResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/list'>>>;
type NoiseSensorsNoiseThresholdsListOptions = never;
type NoiseSensorsNoiseThresholdsUpdateBody = RouteRequestBody<'/noise_sensors/noise_thresholds/update'>;
type NoiseSensorsNoiseThresholdsUpdateResponse = SetNonNullable<Required<RouteResponse<'/noise_sensors/noise_thresholds/update'>>>;
type NoiseSensorsNoiseThresholdsUpdateOptions = never;

declare class SeamHttpNoiseSensors {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpNoiseSensors;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpNoiseSensors;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpNoiseSensors;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpNoiseSensors>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpNoiseSensors;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpNoiseSensors;
    get noiseThresholds(): SeamHttpNoiseSensorsNoiseThresholds;
}

declare class SeamHttpPhones {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpPhones;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpPhones;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpPhones;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpPhones>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpPhones;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpPhones;
    list(body?: PhonesListParams): Promise<PhonesListResponse['phones']>;
}
type PhonesListParams = RouteRequestBody<'/phones/list'>;
type PhonesListResponse = SetNonNullable<Required<RouteResponse<'/phones/list'>>>;
type PhonesListOptions = never;

declare class SeamHttpThermostatsClimateSettingSchedules {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpThermostatsClimateSettingSchedules;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpThermostatsClimateSettingSchedules;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpThermostatsClimateSettingSchedules;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpThermostatsClimateSettingSchedules>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpThermostatsClimateSettingSchedules;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpThermostatsClimateSettingSchedules;
    create(body?: ThermostatsClimateSettingSchedulesCreateBody): Promise<ThermostatsClimateSettingSchedulesCreateResponse['climate_setting_schedule']>;
    delete(body?: ThermostatsClimateSettingSchedulesDeleteBody): Promise<void>;
    get(body?: ThermostatsClimateSettingSchedulesGetParams): Promise<ThermostatsClimateSettingSchedulesGetResponse['climate_setting_schedule']>;
    list(body?: ThermostatsClimateSettingSchedulesListParams): Promise<ThermostatsClimateSettingSchedulesListResponse['climate_setting_schedules']>;
    update(body?: ThermostatsClimateSettingSchedulesUpdateBody): Promise<void>;
}
type ThermostatsClimateSettingSchedulesCreateBody = RouteRequestBody<'/thermostats/climate_setting_schedules/create'>;
type ThermostatsClimateSettingSchedulesCreateResponse = SetNonNullable<Required<RouteResponse<'/thermostats/climate_setting_schedules/create'>>>;
type ThermostatsClimateSettingSchedulesCreateOptions = never;
type ThermostatsClimateSettingSchedulesDeleteBody = RouteRequestBody<'/thermostats/climate_setting_schedules/delete'>;
type ThermostatsClimateSettingSchedulesDeleteResponse = SetNonNullable<Required<RouteResponse<'/thermostats/climate_setting_schedules/delete'>>>;
type ThermostatsClimateSettingSchedulesDeleteOptions = never;
type ThermostatsClimateSettingSchedulesGetParams = RouteRequestBody<'/thermostats/climate_setting_schedules/get'>;
type ThermostatsClimateSettingSchedulesGetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/climate_setting_schedules/get'>>>;
type ThermostatsClimateSettingSchedulesGetOptions = never;
type ThermostatsClimateSettingSchedulesListParams = RouteRequestBody<'/thermostats/climate_setting_schedules/list'>;
type ThermostatsClimateSettingSchedulesListResponse = SetNonNullable<Required<RouteResponse<'/thermostats/climate_setting_schedules/list'>>>;
type ThermostatsClimateSettingSchedulesListOptions = never;
type ThermostatsClimateSettingSchedulesUpdateBody = RouteRequestBody<'/thermostats/climate_setting_schedules/update'>;
type ThermostatsClimateSettingSchedulesUpdateResponse = SetNonNullable<Required<RouteResponse<'/thermostats/climate_setting_schedules/update'>>>;
type ThermostatsClimateSettingSchedulesUpdateOptions = never;

declare class SeamHttpThermostats {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpThermostats;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpThermostats;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpThermostats;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpThermostats>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpThermostats;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpThermostats;
    get climateSettingSchedules(): SeamHttpThermostatsClimateSettingSchedules;
    cool(body?: ThermostatsCoolBody): Promise<void>;
    get(body?: ThermostatsGetParams): Promise<ThermostatsGetResponse['thermostat']>;
    heat(body?: ThermostatsHeatBody): Promise<void>;
    heatCool(body?: ThermostatsHeatCoolBody): Promise<void>;
    list(body?: ThermostatsListParams): Promise<ThermostatsListResponse['thermostats']>;
    off(body?: ThermostatsOffBody): Promise<void>;
    setFanMode(body?: ThermostatsSetFanModeBody): Promise<void>;
    update(body?: ThermostatsUpdateBody): Promise<void>;
}
type ThermostatsCoolBody = RouteRequestBody<'/thermostats/cool'>;
type ThermostatsCoolResponse = SetNonNullable<Required<RouteResponse<'/thermostats/cool'>>>;
type ThermostatsCoolOptions = never;
type ThermostatsGetParams = RouteRequestBody<'/thermostats/get'>;
type ThermostatsGetResponse = SetNonNullable<Required<RouteResponse<'/thermostats/get'>>>;
type ThermostatsGetOptions = never;
type ThermostatsHeatBody = RouteRequestBody<'/thermostats/heat'>;
type ThermostatsHeatResponse = SetNonNullable<Required<RouteResponse<'/thermostats/heat'>>>;
type ThermostatsHeatOptions = never;
type ThermostatsHeatCoolBody = RouteRequestBody<'/thermostats/heat_cool'>;
type ThermostatsHeatCoolResponse = SetNonNullable<Required<RouteResponse<'/thermostats/heat_cool'>>>;
type ThermostatsHeatCoolOptions = never;
type ThermostatsListParams = RouteRequestBody<'/thermostats/list'>;
type ThermostatsListResponse = SetNonNullable<Required<RouteResponse<'/thermostats/list'>>>;
type ThermostatsListOptions = never;
type ThermostatsOffBody = RouteRequestBody<'/thermostats/off'>;
type ThermostatsOffResponse = SetNonNullable<Required<RouteResponse<'/thermostats/off'>>>;
type ThermostatsOffOptions = never;
type ThermostatsSetFanModeBody = RouteRequestBody<'/thermostats/set_fan_mode'>;
type ThermostatsSetFanModeResponse = SetNonNullable<Required<RouteResponse<'/thermostats/set_fan_mode'>>>;
type ThermostatsSetFanModeOptions = never;
type ThermostatsUpdateBody = RouteRequestBody<'/thermostats/update'>;
type ThermostatsUpdateResponse = SetNonNullable<Required<RouteResponse<'/thermostats/update'>>>;
type ThermostatsUpdateOptions = never;

declare class SeamHttpUserIdentitiesEnrollmentAutomations {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpUserIdentitiesEnrollmentAutomations>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpUserIdentitiesEnrollmentAutomations;
    get(body?: UserIdentitiesEnrollmentAutomationsGetParams): Promise<UserIdentitiesEnrollmentAutomationsGetResponse['enrollment_automation']>;
    launch(body?: UserIdentitiesEnrollmentAutomationsLaunchBody): Promise<UserIdentitiesEnrollmentAutomationsLaunchResponse['enrollment_automation']>;
    list(body?: UserIdentitiesEnrollmentAutomationsListParams): Promise<UserIdentitiesEnrollmentAutomationsListResponse['enrollment_automations']>;
}
type UserIdentitiesEnrollmentAutomationsGetParams = RouteRequestBody<'/user_identities/enrollment_automations/get'>;
type UserIdentitiesEnrollmentAutomationsGetResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/get'>>>;
type UserIdentitiesEnrollmentAutomationsGetOptions = never;
type UserIdentitiesEnrollmentAutomationsLaunchBody = RouteRequestBody<'/user_identities/enrollment_automations/launch'>;
type UserIdentitiesEnrollmentAutomationsLaunchResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/launch'>>>;
type UserIdentitiesEnrollmentAutomationsLaunchOptions = never;
type UserIdentitiesEnrollmentAutomationsListParams = RouteRequestBody<'/user_identities/enrollment_automations/list'>;
type UserIdentitiesEnrollmentAutomationsListResponse = SetNonNullable<Required<RouteResponse<'/user_identities/enrollment_automations/list'>>>;
type UserIdentitiesEnrollmentAutomationsListOptions = never;

declare class SeamHttpUserIdentities {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpUserIdentities;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpUserIdentities;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpUserIdentities;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpUserIdentities>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpUserIdentities;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpUserIdentities;
    get enrollmentAutomations(): SeamHttpUserIdentitiesEnrollmentAutomations;
    addAcsUser(body?: UserIdentitiesAddAcsUserBody): Promise<void>;
    create(body?: UserIdentitiesCreateBody): Promise<UserIdentitiesCreateResponse['user_identity']>;
    get(body?: UserIdentitiesGetParams): Promise<UserIdentitiesGetResponse['user_identity']>;
    grantAccessToDevice(body?: UserIdentitiesGrantAccessToDeviceBody): Promise<void>;
    list(body?: UserIdentitiesListParams): Promise<UserIdentitiesListResponse['user_identities']>;
    listAccessibleDevices(body?: UserIdentitiesListAccessibleDevicesParams): Promise<UserIdentitiesListAccessibleDevicesResponse['accessible_devices']>;
    listAcsSystems(body?: UserIdentitiesListAcsSystemsParams): Promise<UserIdentitiesListAcsSystemsResponse['acs_systems']>;
    listAcsUsers(body?: UserIdentitiesListAcsUsersParams): Promise<UserIdentitiesListAcsUsersResponse['acs_users']>;
    removeAcsUser(body?: UserIdentitiesRemoveAcsUserBody): Promise<void>;
    revokeAccessToDevice(body?: UserIdentitiesRevokeAccessToDeviceBody): Promise<void>;
}
type UserIdentitiesAddAcsUserBody = RouteRequestBody<'/user_identities/add_acs_user'>;
type UserIdentitiesAddAcsUserResponse = SetNonNullable<Required<RouteResponse<'/user_identities/add_acs_user'>>>;
type UserIdentitiesAddAcsUserOptions = never;
type UserIdentitiesCreateBody = RouteRequestBody<'/user_identities/create'>;
type UserIdentitiesCreateResponse = SetNonNullable<Required<RouteResponse<'/user_identities/create'>>>;
type UserIdentitiesCreateOptions = never;
type UserIdentitiesGetParams = RouteRequestBody<'/user_identities/get'>;
type UserIdentitiesGetResponse = SetNonNullable<Required<RouteResponse<'/user_identities/get'>>>;
type UserIdentitiesGetOptions = never;
type UserIdentitiesGrantAccessToDeviceBody = RouteRequestBody<'/user_identities/grant_access_to_device'>;
type UserIdentitiesGrantAccessToDeviceResponse = SetNonNullable<Required<RouteResponse<'/user_identities/grant_access_to_device'>>>;
type UserIdentitiesGrantAccessToDeviceOptions = never;
type UserIdentitiesListParams = RouteRequestBody<'/user_identities/list'>;
type UserIdentitiesListResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list'>>>;
type UserIdentitiesListOptions = never;
type UserIdentitiesListAccessibleDevicesParams = RouteRequestBody<'/user_identities/list_accessible_devices'>;
type UserIdentitiesListAccessibleDevicesResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_accessible_devices'>>>;
type UserIdentitiesListAccessibleDevicesOptions = never;
type UserIdentitiesListAcsSystemsParams = RouteRequestBody<'/user_identities/list_acs_systems'>;
type UserIdentitiesListAcsSystemsResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_acs_systems'>>>;
type UserIdentitiesListAcsSystemsOptions = never;
type UserIdentitiesListAcsUsersParams = RouteRequestBody<'/user_identities/list_acs_users'>;
type UserIdentitiesListAcsUsersResponse = SetNonNullable<Required<RouteResponse<'/user_identities/list_acs_users'>>>;
type UserIdentitiesListAcsUsersOptions = never;
type UserIdentitiesRemoveAcsUserBody = RouteRequestBody<'/user_identities/remove_acs_user'>;
type UserIdentitiesRemoveAcsUserResponse = SetNonNullable<Required<RouteResponse<'/user_identities/remove_acs_user'>>>;
type UserIdentitiesRemoveAcsUserOptions = never;
type UserIdentitiesRevokeAccessToDeviceBody = RouteRequestBody<'/user_identities/revoke_access_to_device'>;
type UserIdentitiesRevokeAccessToDeviceResponse = SetNonNullable<Required<RouteResponse<'/user_identities/revoke_access_to_device'>>>;
type UserIdentitiesRevokeAccessToDeviceOptions = never;

declare class SeamHttpWebhooks {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpWebhooks;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpWebhooks;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpWebhooks;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpWebhooks>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpWebhooks;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpWebhooks;
    create(body?: WebhooksCreateBody): Promise<WebhooksCreateResponse['webhook']>;
    delete(body?: WebhooksDeleteBody): Promise<void>;
    get(body?: WebhooksGetParams): Promise<WebhooksGetResponse['webhook']>;
    list(body?: WebhooksListParams): Promise<WebhooksListResponse['webhooks']>;
}
type WebhooksCreateBody = RouteRequestBody<'/webhooks/create'>;
type WebhooksCreateResponse = SetNonNullable<Required<RouteResponse<'/webhooks/create'>>>;
type WebhooksCreateOptions = never;
type WebhooksDeleteBody = RouteRequestBody<'/webhooks/delete'>;
type WebhooksDeleteResponse = SetNonNullable<Required<RouteResponse<'/webhooks/delete'>>>;
type WebhooksDeleteOptions = never;
type WebhooksGetParams = RouteRequestBody<'/webhooks/get'>;
type WebhooksGetResponse = SetNonNullable<Required<RouteResponse<'/webhooks/get'>>>;
type WebhooksGetOptions = never;
type WebhooksListParams = RouteRequestBody<'/webhooks/list'>;
type WebhooksListResponse = SetNonNullable<Required<RouteResponse<'/webhooks/list'>>>;
type WebhooksListOptions = never;

declare class SeamHttpWorkspaces {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttpWorkspaces;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttpWorkspaces;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttpWorkspaces;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttpWorkspaces>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttpWorkspaces;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttpWorkspaces;
    create(body?: WorkspacesCreateBody): Promise<WorkspacesCreateResponse['workspace']>;
    get(body?: WorkspacesGetParams): Promise<WorkspacesGetResponse['workspace']>;
    list(body?: WorkspacesListParams): Promise<WorkspacesListResponse['workspaces']>;
    resetSandbox(body?: WorkspacesResetSandboxBody): Promise<void>;
}
type WorkspacesCreateBody = RouteRequestBody<'/workspaces/create'>;
type WorkspacesCreateResponse = SetNonNullable<Required<RouteResponse<'/workspaces/create'>>>;
type WorkspacesCreateOptions = never;
type WorkspacesGetParams = RouteRequestBody<'/workspaces/get'>;
type WorkspacesGetResponse = SetNonNullable<Required<RouteResponse<'/workspaces/get'>>>;
type WorkspacesGetOptions = never;
type WorkspacesListParams = RouteRequestBody<'/workspaces/list'>;
type WorkspacesListResponse = SetNonNullable<Required<RouteResponse<'/workspaces/list'>>>;
type WorkspacesListOptions = never;
type WorkspacesResetSandboxBody = RouteRequestBody<'/workspaces/reset_sandbox'>;
type WorkspacesResetSandboxResponse = SetNonNullable<Required<RouteResponse<'/workspaces/reset_sandbox'>>>;
type WorkspacesResetSandboxOptions = never;

interface ResolveActionAttemptOptions {
    timeout?: number;
    pollingInterval?: number;
}
declare const isSeamActionAttemptError: <T extends ActionAttempt>(error: unknown) => error is SeamActionAttemptError<T>;
declare class SeamActionAttemptError<T extends ActionAttempt> extends Error {
    actionAttempt: T;
    constructor(message: string, actionAttempt: T);
}
declare const isSeamActionAttemptFailedError: <T extends ActionAttempt>(error: unknown) => error is SeamActionAttemptFailedError<T>;
declare class SeamActionAttemptFailedError<T extends ActionAttempt> extends SeamActionAttemptError<T> {
    code: string;
    constructor(actionAttempt: FailedActionAttempt<T>);
}
declare const isSeamActionAttemptTimeoutError: <T extends ActionAttempt>(error: unknown) => error is SeamActionAttemptTimeoutError<T>;
declare class SeamActionAttemptTimeoutError<T extends ActionAttempt> extends SeamActionAttemptError<T> {
    constructor(actionAttempt: T, timeout: number);
}

type SeamHttpMultiWorkspaceOptions = SeamHttpMultiWorkspaceOptionsWithClient | SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken | SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
type SeamHttpOptions = SeamHttpOptionsFromEnv | SeamHttpOptionsWithClient | SeamHttpOptionsWithApiKey | SeamHttpOptionsWithClientSessionToken | SeamHttpOptionsWithConsoleSessionToken | SeamHttpOptionsWithPersonalAccessToken;
interface SeamHttpCommonOptions extends ClientOptions, SeamHttpRequestOptions {
    endpoint?: string;
}
interface SeamHttpRequestOptions {
    waitForActionAttempt?: boolean | ResolveActionAttemptOptions;
}
interface SeamHttpFromPublishableKeyOptions extends SeamHttpCommonOptions {
}
interface SeamHttpOptionsFromEnv extends SeamHttpCommonOptions {
}
interface SeamHttpMultiWorkspaceOptionsWithClient extends SeamHttpRequestOptions {
    client: Client;
}
declare const isSeamHttpMultiWorkspaceOptionsWithClient: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithClient;
interface SeamHttpOptionsWithClient extends SeamHttpRequestOptions {
    client: Client;
}
declare const isSeamHttpOptionsWithClient: (options: SeamHttpOptions) => options is SeamHttpOptionsWithClient;
interface SeamHttpOptionsWithApiKey extends SeamHttpCommonOptions {
    apiKey: string;
}
declare const isSeamHttpOptionsWithApiKey: (options: SeamHttpOptions) => options is SeamHttpOptionsWithApiKey;
interface SeamHttpOptionsWithClientSessionToken extends SeamHttpCommonOptions {
    clientSessionToken: string;
}
declare const isSeamHttpOptionsWithClientSessionToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithClientSessionToken;
interface SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken extends SeamHttpCommonOptions {
    consoleSessionToken: string;
}
declare const isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken;
interface SeamHttpOptionsWithConsoleSessionToken extends SeamHttpCommonOptions {
    consoleSessionToken: string;
    workspaceId: string;
}
declare const isSeamHttpOptionsWithConsoleSessionToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithConsoleSessionToken;
interface SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken extends SeamHttpCommonOptions {
    personalAccessToken: string;
}
declare const isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken: (options: SeamHttpOptions) => options is SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
interface SeamHttpOptionsWithPersonalAccessToken extends SeamHttpCommonOptions {
    personalAccessToken: string;
    workspaceId: string;
}
declare const isSeamHttpOptionsWithPersonalAccessToken: (options: SeamHttpOptions) => options is SeamHttpOptionsWithPersonalAccessToken;
declare class SeamHttpInvalidOptionsError extends Error {
    constructor(message: string);
}
declare class SeamHttpMultiWorkspaceInvalidOptionsError extends SeamHttpInvalidOptionsError {
}

declare class SeamHttpInvalidTokenError extends Error {
    constructor(message: string);
}

declare const errorInterceptor: (err: unknown) => Promise<void>;

declare const getOpenapiSchema: (endpoint?: string) => Promise<typeof openapi>;

declare class SeamHttp {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(apiKeyOrOptions?: string | SeamHttpOptions);
    static fromClient(client: SeamHttpOptionsWithClient['client'], options?: Omit<SeamHttpOptionsWithClient, 'client'>): SeamHttp;
    static fromApiKey(apiKey: SeamHttpOptionsWithApiKey['apiKey'], options?: Omit<SeamHttpOptionsWithApiKey, 'apiKey'>): SeamHttp;
    static fromClientSessionToken(clientSessionToken: SeamHttpOptionsWithClientSessionToken['clientSessionToken'], options?: Omit<SeamHttpOptionsWithClientSessionToken, 'clientSessionToken'>): SeamHttp;
    static fromPublishableKey(publishableKey: string, userIdentifierKey: string, options?: SeamHttpFromPublishableKeyOptions): Promise<SeamHttp>;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpOptionsWithConsoleSessionToken['consoleSessionToken'], workspaceId: SeamHttpOptionsWithConsoleSessionToken['workspaceId'], options?: Omit<SeamHttpOptionsWithConsoleSessionToken, 'consoleSessionToken' | 'workspaceId'>): SeamHttp;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpOptionsWithPersonalAccessToken['personalAccessToken'], workspaceId: SeamHttpOptionsWithPersonalAccessToken['workspaceId'], options?: Omit<SeamHttpOptionsWithPersonalAccessToken, 'personalAccessToken' | 'workspaceId'>): SeamHttp;
    get accessCodes(): SeamHttpAccessCodes;
    get acs(): SeamHttpAcs;
    get actionAttempts(): SeamHttpActionAttempts;
    get clientSessions(): SeamHttpClientSessions;
    get connectedAccounts(): SeamHttpConnectedAccounts;
    get connectWebviews(): SeamHttpConnectWebviews;
    get devices(): SeamHttpDevices;
    get events(): SeamHttpEvents;
    get locks(): SeamHttpLocks;
    get networks(): SeamHttpNetworks;
    get noiseSensors(): SeamHttpNoiseSensors;
    get phones(): SeamHttpPhones;
    get thermostats(): SeamHttpThermostats;
    get userIdentities(): SeamHttpUserIdentities;
    get webhooks(): SeamHttpWebhooks;
    get workspaces(): Omit<SeamHttpWorkspaces, 'create'>;
}

interface ApiError {
    type: string;
    message: string;
    data?: unknown;
}

declare class SeamHttpApiError extends Error {
    code: string;
    statusCode: number;
    requestId: string;
    data?: unknown;
    constructor(error: ApiError, statusCode: number, requestId: string);
}
declare const isSeamHttpApiError: (error: unknown) => error is SeamHttpApiError;
declare class SeamHttpUnauthorizedError extends SeamHttpApiError {
    code: 'unauthorized';
    statusCode: 401;
    constructor(requestId: string);
}
declare const isSeamHttpUnauthorizedError: (error: unknown) => error is SeamHttpUnauthorizedError;
declare class SeamHttpInvalidInputError extends SeamHttpApiError {
    code: 'invalid_input';
    constructor(error: ApiError, statusCode: number, requestId: string);
}
declare const isSeamHttpInvalidInputError: (error: unknown) => error is SeamHttpInvalidInputError;

declare class SeamHttpMultiWorkspace {
    client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
    constructor(options: SeamHttpMultiWorkspaceOptions);
    static fromClient(client: SeamHttpMultiWorkspaceOptionsWithClient['client'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithClient, 'client'>): SeamHttpMultiWorkspace;
    static fromConsoleSessionToken(consoleSessionToken: SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken['consoleSessionToken'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, 'consoleSessionToken'>): SeamHttpMultiWorkspace;
    static fromPersonalAccessToken(personalAccessToken: SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken['personalAccessToken'], options?: Omit<SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, 'personalAccessToken'>): SeamHttpMultiWorkspace;
    get workspaces(): Pick<SeamHttpWorkspaces, 'create' | 'list'>;
}

declare const isApiKey: (token: string) => boolean;
declare const isClientSessionToken: (token: string) => boolean;
declare const isPublishableKey: (token: string) => boolean;
declare const isConsoleSessionToken: (token: string) => boolean;
declare const isPersonalAccessToken: (token: string) => boolean;

export { type AccessCodesCreateBody, type AccessCodesCreateMultipleBody, type AccessCodesCreateMultipleOptions, type AccessCodesCreateMultipleResponse, type AccessCodesCreateOptions, type AccessCodesCreateResponse, type AccessCodesDeleteBody, type AccessCodesDeleteOptions, type AccessCodesDeleteResponse, type AccessCodesGenerateCodeBody, type AccessCodesGenerateCodeOptions, type AccessCodesGenerateCodeResponse, type AccessCodesGetOptions, type AccessCodesGetParams, type AccessCodesGetResponse, type AccessCodesListOptions, type AccessCodesListParams, type AccessCodesListResponse, type AccessCodesPullBackupAccessCodeBody, type AccessCodesPullBackupAccessCodeOptions, type AccessCodesPullBackupAccessCodeResponse, type AccessCodesUnmanagedConvertToManagedBody, type AccessCodesUnmanagedConvertToManagedOptions, type AccessCodesUnmanagedConvertToManagedResponse, type AccessCodesUnmanagedDeleteBody, type AccessCodesUnmanagedDeleteOptions, type AccessCodesUnmanagedDeleteResponse, type AccessCodesUnmanagedGetOptions, type AccessCodesUnmanagedGetParams, type AccessCodesUnmanagedGetResponse, type AccessCodesUnmanagedListOptions, type AccessCodesUnmanagedListParams, type AccessCodesUnmanagedListResponse, type AccessCodesUnmanagedUpdateBody, type AccessCodesUnmanagedUpdateOptions, type AccessCodesUnmanagedUpdateResponse, type AccessCodesUpdateBody, type AccessCodesUpdateOptions, type AccessCodesUpdateResponse, type AcsAccessGroupsAddUserBody, type AcsAccessGroupsAddUserOptions, type AcsAccessGroupsAddUserResponse, type AcsAccessGroupsGetOptions, type AcsAccessGroupsGetParams, type AcsAccessGroupsGetResponse, type AcsAccessGroupsListOptions, type AcsAccessGroupsListParams, type AcsAccessGroupsListResponse, type AcsAccessGroupsListUsersOptions, type AcsAccessGroupsListUsersParams, type AcsAccessGroupsListUsersResponse, type AcsAccessGroupsRemoveUserBody, type AcsAccessGroupsRemoveUserOptions, type AcsAccessGroupsRemoveUserResponse, type AcsCredentialPoolsListOptions, type AcsCredentialPoolsListParams, type AcsCredentialPoolsListResponse, type AcsCredentialProvisioningAutomationsLaunchBody, type AcsCredentialProvisioningAutomationsLaunchOptions, type AcsCredentialProvisioningAutomationsLaunchResponse, type AcsCredentialsAssignBody, type AcsCredentialsAssignOptions, type AcsCredentialsAssignResponse, type AcsCredentialsCreateBody, type AcsCredentialsCreateOptions, type AcsCredentialsCreateResponse, type AcsCredentialsDeleteBody, type AcsCredentialsDeleteOptions, type AcsCredentialsDeleteResponse, type AcsCredentialsGetOptions, type AcsCredentialsGetParams, type AcsCredentialsGetResponse, type AcsCredentialsListOptions, type AcsCredentialsListParams, type AcsCredentialsListResponse, type AcsCredentialsUnassignBody, type AcsCredentialsUnassignOptions, type AcsCredentialsUnassignResponse, type AcsCredentialsUpdateBody, type AcsCredentialsUpdateOptions, type AcsCredentialsUpdateResponse, type AcsEntrancesGetOptions, type AcsEntrancesGetParams, type AcsEntrancesGetResponse, type AcsEntrancesGrantAccessBody, type AcsEntrancesGrantAccessOptions, type AcsEntrancesGrantAccessResponse, type AcsEntrancesListOptions, type AcsEntrancesListParams, type AcsEntrancesListResponse, type AcsSystemsGetOptions, type AcsSystemsGetParams, type AcsSystemsGetResponse, type AcsSystemsListOptions, type AcsSystemsListParams, type AcsSystemsListResponse, type AcsUsersAddToAccessGroupBody, type AcsUsersAddToAccessGroupOptions, type AcsUsersAddToAccessGroupResponse, type AcsUsersCreateBody, type AcsUsersCreateOptions, type AcsUsersCreateResponse, type AcsUsersDeleteBody, type AcsUsersDeleteOptions, type AcsUsersDeleteResponse, type AcsUsersGetOptions, type AcsUsersGetParams, type AcsUsersGetResponse, type AcsUsersListAccessibleEntrancesOptions, type AcsUsersListAccessibleEntrancesParams, type AcsUsersListAccessibleEntrancesResponse, type AcsUsersListOptions, type AcsUsersListParams, type AcsUsersListResponse, type AcsUsersRemoveFromAccessGroupBody, type AcsUsersRemoveFromAccessGroupOptions, type AcsUsersRemoveFromAccessGroupResponse, type AcsUsersSuspendBody, type AcsUsersSuspendOptions, type AcsUsersSuspendResponse, type AcsUsersUnsuspendBody, type AcsUsersUnsuspendOptions, type AcsUsersUnsuspendResponse, type AcsUsersUpdateBody, type AcsUsersUpdateOptions, type AcsUsersUpdateResponse, type ActionAttemptsGetOptions, type ActionAttemptsGetParams, type ActionAttemptsGetResponse, type ActionAttemptsListOptions, type ActionAttemptsListParams, type ActionAttemptsListResponse, type ClientSessionsCreateBody, type ClientSessionsCreateOptions, type ClientSessionsCreateResponse, type ClientSessionsDeleteBody, type ClientSessionsDeleteOptions, type ClientSessionsDeleteResponse, type ClientSessionsGetOptions, type ClientSessionsGetOrCreateBody, type ClientSessionsGetOrCreateOptions, type ClientSessionsGetOrCreateResponse, type ClientSessionsGetParams, type ClientSessionsGetResponse, type ClientSessionsGrantAccessBody, type ClientSessionsGrantAccessOptions, type ClientSessionsGrantAccessResponse, type ClientSessionsListOptions, type ClientSessionsListParams, type ClientSessionsListResponse, type ClientSessionsRevokeBody, type ClientSessionsRevokeOptions, type ClientSessionsRevokeResponse, type ConnectWebviewsCreateBody, type ConnectWebviewsCreateOptions, type ConnectWebviewsCreateResponse, type ConnectWebviewsDeleteBody, type ConnectWebviewsDeleteOptions, type ConnectWebviewsDeleteResponse, type ConnectWebviewsGetOptions, type ConnectWebviewsGetParams, type ConnectWebviewsGetResponse, type ConnectWebviewsListOptions, type ConnectWebviewsListParams, type ConnectWebviewsListResponse, type ConnectWebviewsViewOptions, type ConnectWebviewsViewParams, type ConnectWebviewsViewResponse, type ConnectedAccountsDeleteBody, type ConnectedAccountsDeleteOptions, type ConnectedAccountsDeleteResponse, type ConnectedAccountsGetOptions, type ConnectedAccountsGetParams, type ConnectedAccountsGetResponse, type ConnectedAccountsListOptions, type ConnectedAccountsListParams, type ConnectedAccountsListResponse, type ConnectedAccountsUpdateBody, type ConnectedAccountsUpdateOptions, type ConnectedAccountsUpdateResponse, type DevicesDeleteBody, type DevicesDeleteOptions, type DevicesDeleteResponse, type DevicesGetOptions, type DevicesGetParams, type DevicesGetResponse, type DevicesListDeviceProvidersOptions, type DevicesListDeviceProvidersParams, type DevicesListDeviceProvidersResponse, type DevicesListOptions, type DevicesListParams, type DevicesListResponse, type DevicesUnmanagedGetOptions, type DevicesUnmanagedGetParams, type DevicesUnmanagedGetResponse, type DevicesUnmanagedListOptions, type DevicesUnmanagedListParams, type DevicesUnmanagedListResponse, type DevicesUnmanagedUpdateBody, type DevicesUnmanagedUpdateOptions, type DevicesUnmanagedUpdateResponse, type DevicesUpdateBody, type DevicesUpdateOptions, type DevicesUpdateResponse, type EventsGetOptions, type EventsGetParams, type EventsGetResponse, type EventsListOptions, type EventsListParams, type EventsListResponse, type LocksGetOptions, type LocksGetParams, type LocksGetResponse, type LocksListOptions, type LocksListParams, type LocksListResponse, type LocksLockDoorBody, type LocksLockDoorOptions, type LocksLockDoorResponse, type LocksUnlockDoorBody, type LocksUnlockDoorOptions, type LocksUnlockDoorResponse, type NetworksGetOptions, type NetworksGetParams, type NetworksGetResponse, type NetworksListOptions, type NetworksListParams, type NetworksListResponse, type NoiseSensorsNoiseThresholdsCreateBody, type NoiseSensorsNoiseThresholdsCreateOptions, type NoiseSensorsNoiseThresholdsCreateResponse, type NoiseSensorsNoiseThresholdsDeleteBody, type NoiseSensorsNoiseThresholdsDeleteOptions, type NoiseSensorsNoiseThresholdsDeleteResponse, type NoiseSensorsNoiseThresholdsGetOptions, type NoiseSensorsNoiseThresholdsGetParams, type NoiseSensorsNoiseThresholdsGetResponse, type NoiseSensorsNoiseThresholdsListOptions, type NoiseSensorsNoiseThresholdsListParams, type NoiseSensorsNoiseThresholdsListResponse, type NoiseSensorsNoiseThresholdsUpdateBody, type NoiseSensorsNoiseThresholdsUpdateOptions, type NoiseSensorsNoiseThresholdsUpdateResponse, type PhonesListOptions, type PhonesListParams, type PhonesListResponse, SeamActionAttemptError, SeamActionAttemptFailedError, SeamActionAttemptTimeoutError, SeamHttp, SeamHttpAccessCodes, SeamHttpAccessCodesUnmanaged, SeamHttpAcs, SeamHttpAcsAccessGroups, SeamHttpAcsCredentialPools, SeamHttpAcsCredentialProvisioningAutomations, SeamHttpAcsCredentials, SeamHttpAcsEntrances, SeamHttpAcsSystems, SeamHttpAcsUsers, SeamHttpActionAttempts, SeamHttpApiError, SeamHttpClientSessions, SeamHttpConnectWebviews, SeamHttpConnectedAccounts, SeamHttpDevices, SeamHttpDevicesUnmanaged, SeamHttpEvents, type SeamHttpFromPublishableKeyOptions, SeamHttpInvalidInputError, SeamHttpInvalidOptionsError, SeamHttpInvalidTokenError, SeamHttpLocks, SeamHttpMultiWorkspace, SeamHttpMultiWorkspaceInvalidOptionsError, type SeamHttpMultiWorkspaceOptions, type SeamHttpMultiWorkspaceOptionsWithClient, type SeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, type SeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, SeamHttpNetworks, SeamHttpNoiseSensors, SeamHttpNoiseSensorsNoiseThresholds, type SeamHttpOptions, type SeamHttpOptionsFromEnv, type SeamHttpOptionsWithApiKey, type SeamHttpOptionsWithClient, type SeamHttpOptionsWithClientSessionToken, type SeamHttpOptionsWithConsoleSessionToken, type SeamHttpOptionsWithPersonalAccessToken, SeamHttpPhones, type SeamHttpRequestOptions, SeamHttpThermostats, SeamHttpThermostatsClimateSettingSchedules, SeamHttpUnauthorizedError, SeamHttpUserIdentities, SeamHttpUserIdentitiesEnrollmentAutomations, SeamHttpWebhooks, SeamHttpWorkspaces, type ThermostatsClimateSettingSchedulesCreateBody, type ThermostatsClimateSettingSchedulesCreateOptions, type ThermostatsClimateSettingSchedulesCreateResponse, type ThermostatsClimateSettingSchedulesDeleteBody, type ThermostatsClimateSettingSchedulesDeleteOptions, type ThermostatsClimateSettingSchedulesDeleteResponse, type ThermostatsClimateSettingSchedulesGetOptions, type ThermostatsClimateSettingSchedulesGetParams, type ThermostatsClimateSettingSchedulesGetResponse, type ThermostatsClimateSettingSchedulesListOptions, type ThermostatsClimateSettingSchedulesListParams, type ThermostatsClimateSettingSchedulesListResponse, type ThermostatsClimateSettingSchedulesUpdateBody, type ThermostatsClimateSettingSchedulesUpdateOptions, type ThermostatsClimateSettingSchedulesUpdateResponse, type ThermostatsCoolBody, type ThermostatsCoolOptions, type ThermostatsCoolResponse, type ThermostatsGetOptions, type ThermostatsGetParams, type ThermostatsGetResponse, type ThermostatsHeatBody, type ThermostatsHeatCoolBody, type ThermostatsHeatCoolOptions, type ThermostatsHeatCoolResponse, type ThermostatsHeatOptions, type ThermostatsHeatResponse, type ThermostatsListOptions, type ThermostatsListParams, type ThermostatsListResponse, type ThermostatsOffBody, type ThermostatsOffOptions, type ThermostatsOffResponse, type ThermostatsSetFanModeBody, type ThermostatsSetFanModeOptions, type ThermostatsSetFanModeResponse, type ThermostatsUpdateBody, type ThermostatsUpdateOptions, type ThermostatsUpdateResponse, type UserIdentitiesAddAcsUserBody, type UserIdentitiesAddAcsUserOptions, type UserIdentitiesAddAcsUserResponse, type UserIdentitiesCreateBody, type UserIdentitiesCreateOptions, type UserIdentitiesCreateResponse, type UserIdentitiesEnrollmentAutomationsGetOptions, type UserIdentitiesEnrollmentAutomationsGetParams, type UserIdentitiesEnrollmentAutomationsGetResponse, type UserIdentitiesEnrollmentAutomationsLaunchBody, type UserIdentitiesEnrollmentAutomationsLaunchOptions, type UserIdentitiesEnrollmentAutomationsLaunchResponse, type UserIdentitiesEnrollmentAutomationsListOptions, type UserIdentitiesEnrollmentAutomationsListParams, type UserIdentitiesEnrollmentAutomationsListResponse, type UserIdentitiesGetOptions, type UserIdentitiesGetParams, type UserIdentitiesGetResponse, type UserIdentitiesGrantAccessToDeviceBody, type UserIdentitiesGrantAccessToDeviceOptions, type UserIdentitiesGrantAccessToDeviceResponse, type UserIdentitiesListAccessibleDevicesOptions, type UserIdentitiesListAccessibleDevicesParams, type UserIdentitiesListAccessibleDevicesResponse, type UserIdentitiesListAcsSystemsOptions, type UserIdentitiesListAcsSystemsParams, type UserIdentitiesListAcsSystemsResponse, type UserIdentitiesListAcsUsersOptions, type UserIdentitiesListAcsUsersParams, type UserIdentitiesListAcsUsersResponse, type UserIdentitiesListOptions, type UserIdentitiesListParams, type UserIdentitiesListResponse, type UserIdentitiesRemoveAcsUserBody, type UserIdentitiesRemoveAcsUserOptions, type UserIdentitiesRemoveAcsUserResponse, type UserIdentitiesRevokeAccessToDeviceBody, type UserIdentitiesRevokeAccessToDeviceOptions, type UserIdentitiesRevokeAccessToDeviceResponse, type WebhooksCreateBody, type WebhooksCreateOptions, type WebhooksCreateResponse, type WebhooksDeleteBody, type WebhooksDeleteOptions, type WebhooksDeleteResponse, type WebhooksGetOptions, type WebhooksGetParams, type WebhooksGetResponse, type WebhooksListOptions, type WebhooksListParams, type WebhooksListResponse, type WorkspacesCreateBody, type WorkspacesCreateOptions, type WorkspacesCreateResponse, type WorkspacesGetOptions, type WorkspacesGetParams, type WorkspacesGetResponse, type WorkspacesListOptions, type WorkspacesListParams, type WorkspacesListResponse, type WorkspacesResetSandboxBody, type WorkspacesResetSandboxOptions, type WorkspacesResetSandboxResponse, errorInterceptor, getOpenapiSchema, isApiKey, isClientSessionToken, isConsoleSessionToken, isPersonalAccessToken, isPublishableKey, isSeamActionAttemptError, isSeamActionAttemptFailedError, isSeamActionAttemptTimeoutError, isSeamHttpApiError, isSeamHttpInvalidInputError, isSeamHttpMultiWorkspaceOptionsWithClient, isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken, isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken, isSeamHttpOptionsWithApiKey, isSeamHttpOptionsWithClient, isSeamHttpOptionsWithClientSessionToken, isSeamHttpOptionsWithConsoleSessionToken, isSeamHttpOptionsWithPersonalAccessToken, isSeamHttpUnauthorizedError };
