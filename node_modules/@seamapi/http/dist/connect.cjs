'use strict';

var axios = require('axios');
var urlSearchParamsSerializer = require('@seamapi/url-search-params-serializer');
var axiosBetterStacktrace = require('axios-better-stacktrace');
var axiosRetry = require('axios-retry');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);
var axiosBetterStacktrace__default = /*#__PURE__*/_interopDefault(axiosBetterStacktrace);
var axiosRetry__default = /*#__PURE__*/_interopDefault(axiosRetry);

// src/lib/version.ts
var seamapiJavascriptHttpVersion = null;
var version_default = seamapiJavascriptHttpVersion;

// src/lib/seam/connect/parse-options.ts
var defaultEndpoint = "https://connect.getseam.com";
var sdkHeaders = {
  "seam-sdk-name": "seamapi/javascript-http",
  "seam-sdk-version": version_default
};
var parseOptions = (apiKeyOrOptions) => {
  const options = getNormalizedOptions(apiKeyOrOptions);
  if (isSeamHttpOptionsWithClient(options))
    return options;
  if (isSeamHttpMultiWorkspaceOptionsWithClient(options))
    return options;
  return {
    ...options,
    axiosOptions: {
      baseURL: options.endpoint ?? getEndpointFromEnv() ?? defaultEndpoint,
      withCredentials: isSeamHttpOptionsWithClientSessionToken(options),
      ...options.axiosOptions,
      headers: {
        ...getAuthHeaders(options),
        ...options.axiosOptions?.headers,
        ...sdkHeaders
      }
    },
    axiosRetryOptions: {
      ...options.axiosRetryOptions
    }
  };
};
var getNormalizedOptions = (apiKeyOrOptions) => {
  const options = typeof apiKeyOrOptions === "string" ? { apiKey: apiKeyOrOptions } : apiKeyOrOptions;
  const requestOptions = {
    waitForActionAttempt: options.waitForActionAttempt ?? false
  };
  if (isSeamHttpOptionsWithClient(options)) {
    return {
      ...options,
      ...requestOptions
    };
  }
  const apiKey = "apiKey" in options ? options.apiKey : getApiKeyFromEnv(options);
  return {
    ...options,
    ...apiKey != null ? { apiKey } : {},
    ...requestOptions
  };
};
var getApiKeyFromEnv = (options) => {
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    return null;
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    return null;
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    return null;
  }
  return globalThis.process?.env?.SEAM_API_KEY;
};
var getEndpointFromEnv = () => {
  if (globalThis.process?.env?.SEAM_API_URL != null) {
    console.warn(
      "Using the SEAM_API_URL environment variable is deprecated. Support will be remove in a later major version. Use SEAM_ENDPOINT instead."
    );
  }
  if (globalThis.process?.env?.SEAM_API_URL != null && globalThis.process?.env?.SEAM_ENDPOINT != null) {
    console.warn(
      "Detected both the SEAM_API_URL and SEAM_ENDPOINT environment variables. Using SEAM_ENDPOINT."
    );
  }
  return globalThis.process?.env?.SEAM_ENDPOINT ?? globalThis.process?.env?.SEAM_API_URL;
};
var limitToSeamHttpRequestOptions = (options) => {
  return Object.keys(options).filter(isSeamHttpRequestOption).reduce(
    (obj, key) => ({
      ...obj,
      [key]: options[key]
    }),
    {}
  );
};
var isSeamHttpRequestOption = (key) => {
  const keys = {
    waitForActionAttempt: true
  };
  return Object.keys(keys).includes(key);
};

// src/lib/seam/connect/options.ts
var isSeamHttpMultiWorkspaceOptionsWithClient = (options) => isSeamHttpOptionsWithClient(options);
var isSeamHttpOptionsWithClient = (options) => {
  if (!("client" in options))
    return false;
  if (options.client == null)
    return false;
  const keys = Object.keys(options).filter((k) => k !== "client");
  if (keys.filter((k) => !isSeamHttpRequestOption(k)).length > 0) {
    throw new SeamHttpInvalidOptionsError(
      `The client option cannot be used with any other option, but received: ${keys.join(
        ", "
      )}`
    );
  }
  return true;
};
var isSeamHttpOptionsWithApiKey = (options) => {
  if (!("apiKey" in options))
    return false;
  if (options.apiKey == null)
    return false;
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the apiKey option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithClientSessionToken = (options) => {
  if (!("clientSessionToken" in options))
    return false;
  if (options.clientSessionToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the clientSessionToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the clientSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the clientSessionToken option"
    );
  }
  return true;
};
var isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken = (options) => {
  if (!("consoleSessionToken" in options))
    return false;
  if (options.consoleSessionToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the consoleSessionToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the consoleSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the consoleSessionToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithConsoleSessionToken = (options) => {
  if (!isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a consoleSessionToken"
    );
  }
  return true;
};
var isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken = (options) => {
  if (!("personalAccessToken" in options))
    return false;
  if (options.personalAccessToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the personalAccessToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithPersonalAccessToken = (options) => {
  if (!isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a personalAccessToken"
    );
  }
  return true;
};
var SeamHttpInvalidOptionsError = class extends Error {
  constructor(message) {
    super(`SeamHttp received invalid options: ${message}`);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
var SeamHttpMultiWorkspaceInvalidOptionsError = class extends SeamHttpInvalidOptionsError {
};

// src/lib/seam/connect/token.ts
var tokenPrefix = "seam_";
var accessTokenPrefix = "seam_at";
var jwtPrefix = "ey";
var clientSessionTokenPrefix = "seam_cst";
var publishableKeyTokenPrefix = "seam_pk";
var isAccessToken = (token) => token.startsWith(accessTokenPrefix);
var isJwt = (token) => token.startsWith(jwtPrefix);
var isSeamToken = (token) => token.startsWith(tokenPrefix);
var isApiKey = (token) => !isClientSessionToken(token) && !isJwt(token) && !isAccessToken(token) && !isPublishableKey(token) && isSeamToken(token);
var isClientSessionToken = (token) => token.startsWith(clientSessionTokenPrefix);
var isPublishableKey = (token) => token.startsWith(publishableKeyTokenPrefix);
var isConsoleSessionToken = (token) => isJwt(token);
var isPersonalAccessToken = (token) => isAccessToken(token);

// src/lib/seam/connect/auth.ts
var getAuthHeaders = (options) => {
  if ("publishableKey" in options) {
    return getAuthHeadersForPublishableKey(options.publishableKey);
  }
  if (isSeamHttpOptionsWithApiKey(options)) {
    return getAuthHeadersForApiKey(options);
  }
  if (isSeamHttpOptionsWithClientSessionToken(options)) {
    return getAuthHeadersForClientSessionToken(options);
  }
  if (isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options) || isSeamHttpOptionsWithConsoleSessionToken(options)) {
    return getAuthHeadersForConsoleSessionToken(options);
  }
  if (isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options) || isSeamHttpOptionsWithPersonalAccessToken(options)) {
    return getAuthHeadersForPersonalAccessToken(options);
  }
  throw new SeamHttpInvalidOptionsError(
    [
      "Must specify",
      "an apiKey,",
      "clientSessionToken,",
      "publishableKey,",
      "consoleSessionToken",
      "or personalAccessToken.",
      "Attempted reading configuration from the environment, but the environment variable SEAM_API_KEY is not set."
    ].join(" ")
  );
};
var getAuthHeadersForApiKey = ({
  apiKey
}) => {
  if (isClientSessionToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as an apiKey"
    );
  }
  if (isJwt(apiKey)) {
    throw new SeamHttpInvalidTokenError("A JWT cannot be used as an apiKey");
  }
  if (isAccessToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as an apiKey"
    );
  }
  if (isPublishableKey(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as an apiKey"
    );
  }
  if (!isSeamToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid apiKey format, expected token to start with ${tokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${apiKey}`
  };
};
var getAuthHeadersForClientSessionToken = ({
  clientSessionToken
}) => {
  if (isJwt(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a clientSessionToken"
    );
  }
  if (isAccessToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a clientSessionToken"
    );
  }
  if (isPublishableKey(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a clientSessionToken"
    );
  }
  if (!isClientSessionToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid clientSessionToken format, expected token to start with ${clientSessionTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${clientSessionToken}`,
    "client-session-token": clientSessionToken
  };
};
var getAuthHeadersForConsoleSessionToken = ({
  consoleSessionToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isAccessToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a consoleSessionToken"
    );
  }
  if (isClientSessionToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a consoleSessionToken"
    );
  }
  if (isPublishableKey(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a consoleSessionToken"
    );
  }
  if (!isJwt(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid consoleSessionToken format, expected a JWT which starts with ${jwtPrefix}`
    );
  }
  return {
    authorization: `Bearer ${consoleSessionToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPersonalAccessToken = ({
  personalAccessToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isJwt(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a personalAccessToken"
    );
  }
  if (isClientSessionToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a personalAccessToken"
    );
  }
  if (isPublishableKey(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a personalAccessToken"
    );
  }
  if (!isAccessToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid personalAccessToken format, expected token to start with ${accessTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${personalAccessToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPublishableKey = (publishableKey) => {
  if (isJwt(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a publishableKey"
    );
  }
  if (isAccessToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a publishableKey"
    );
  }
  if (isClientSessionToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token Key cannot be used as a publishableKey"
    );
  }
  if (!isPublishableKey(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid publishableKey format, expected token to start with ${publishableKeyTokenPrefix}`
    );
  }
  return {
    "seam-publishable-key": publishableKey
  };
};
var SeamHttpInvalidTokenError = class extends Error {
  constructor(message) {
    super(`SeamHttp received an invalid token: ${message}`);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
var warnOnInsecureuserIdentifierKey = (userIdentifierKey) => {
  if (isEmail(userIdentifierKey)) {
    console.warn(
      ...[
        "Using an email for the userIdentifierKey is insecure and may return an error in the future!",
        "This is insecure because an email is common knowledge or easily guessed.",
        "Use something with sufficient entropy known only to the owner of the client session.",
        "For help choosing a user identifier key see",
        "https://docs.seam.co/latest/seam-components/overview/get-started-with-client-side-components#3-select-a-user-identifier-key"
      ]
    );
  }
};
var isEmail = (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);

// src/lib/seam/connect/seam-http-error.ts
var SeamHttpApiError = class extends Error {
  constructor(error, statusCode, requestId) {
    const { type, message, data } = error;
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
    this.code = type;
    this.statusCode = statusCode;
    this.requestId = requestId;
    if (data != null)
      this.data = data;
  }
};
var isSeamHttpApiError = (error) => {
  return error instanceof SeamHttpApiError;
};
var SeamHttpUnauthorizedError = class extends SeamHttpApiError {
  constructor(requestId) {
    const type = "unauthorized";
    const status = 401;
    super({ type, message: "Unauthorized" }, status, requestId);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
    this.code = type;
    this.statusCode = status;
    this.requestId = requestId;
  }
};
var isSeamHttpUnauthorizedError = (error) => {
  return error instanceof SeamHttpUnauthorizedError;
};
var SeamHttpInvalidInputError = class extends SeamHttpApiError {
  constructor(error, statusCode, requestId) {
    super(error, statusCode, requestId);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
    this.code = "invalid_input";
  }
};
var isSeamHttpInvalidInputError = (error) => {
  return error instanceof SeamHttpInvalidInputError;
};

// src/lib/seam/connect/error-interceptor.ts
var errorInterceptor = async (err) => {
  if (!axios.isAxiosError(err))
    throw err;
  const { response } = err;
  const status = response?.status;
  const requestId = getRequestId(err);
  if (status == null)
    throw err;
  if (status === 401) {
    throw new SeamHttpUnauthorizedError(requestId);
  }
  if (!isApiErrorResponse(response))
    throw err;
  const { type } = response.data.error;
  const args = [response.data.error, status, requestId];
  if (type === "invalid_input")
    throw new SeamHttpInvalidInputError(...args);
  throw new SeamHttpApiError(...args);
};
var isApiErrorResponse = (response) => {
  if (response == null)
    return false;
  const { headers, data } = response;
  if (headers == null)
    return false;
  const contentType = headers["Content-Type"];
  if (typeof contentType === "string" && !contentType.startsWith("application/json")) {
    return false;
  }
  if (typeof data === "object" && data != null) {
    return "error" in data && typeof data.error === "object" && data.error != null && "type" in data.error && typeof data.error.type === "string";
  }
  return false;
};
var getRequestId = (err) => {
  const headers = err.response?.headers;
  if (headers == null)
    return "";
  const requestId = headers["seam-request-id"];
  if (requestId == null)
    return "";
  return requestId;
};
var createClient = (options) => {
  const client = axios__default.default.create({
    paramsSerializer: urlSearchParamsSerializer.serializeUrlSearchParams,
    ...options.axiosOptions
  });
  axiosBetterStacktrace__default.default(axios__default.default);
  axiosRetry__default.default(client, {
    retries: 2,
    retryDelay: axiosRetry.exponentialDelay,
    ...options.axiosRetryOptions
  });
  client.interceptors.response.use(void 0, errorInterceptor);
  return client;
};

// src/lib/seam/connect/openapi.ts
var getOpenapiSchema = async (endpoint = defaultEndpoint) => {
  const client = createClient({
    axiosOptions: {
      baseURL: endpoint,
      headers: sdkHeaders
    }
  });
  const { data } = await client.get("/openapi.json");
  return data;
};

// src/lib/seam/connect/resolve-action-attempt.ts
var resolveActionAttempt = async (actionAttempt, actionAttempts, { timeout = 5e3, pollingInterval = 500 }) => {
  let timeoutRef;
  const timeoutPromise = new Promise(
    (_resolve, reject) => {
      timeoutRef = globalThis.setTimeout(() => {
        reject(new SeamActionAttemptTimeoutError(actionAttempt, timeout));
      }, timeout);
    }
  );
  try {
    return await Promise.race([
      pollActionAttempt(actionAttempt, actionAttempts, { pollingInterval }),
      timeoutPromise
    ]);
  } finally {
    if (timeoutRef != null)
      globalThis.clearTimeout(timeoutRef);
  }
};
var pollActionAttempt = async (actionAttempt, actionAttempts, options) => {
  if (isSuccessfulActionAttempt(actionAttempt)) {
    return actionAttempt;
  }
  if (isFailedActionAttempt(actionAttempt)) {
    throw new SeamActionAttemptFailedError(actionAttempt);
  }
  await new Promise((resolve) => setTimeout(resolve, options.pollingInterval));
  const nextActionAttempt = await actionAttempts.get({
    action_attempt_id: actionAttempt.action_attempt_id
  });
  return await pollActionAttempt(
    nextActionAttempt,
    actionAttempts,
    options
  );
};
var isSeamActionAttemptError = (error) => {
  return error instanceof SeamActionAttemptError;
};
var SeamActionAttemptError = class extends Error {
  constructor(message, actionAttempt) {
    super(message);
    this.name = this.constructor.name;
    this.actionAttempt = actionAttempt;
    Error.captureStackTrace(this, this.constructor);
  }
};
var isSeamActionAttemptFailedError = (error) => {
  return error instanceof SeamActionAttemptFailedError;
};
var SeamActionAttemptFailedError = class extends SeamActionAttemptError {
  constructor(actionAttempt) {
    super(actionAttempt.error.message, actionAttempt);
    this.name = this.constructor.name;
    this.code = actionAttempt.error.type;
    Error.captureStackTrace(this, this.constructor);
  }
};
var isSeamActionAttemptTimeoutError = (error) => {
  return error instanceof SeamActionAttemptTimeoutError;
};
var SeamActionAttemptTimeoutError = class extends SeamActionAttemptError {
  constructor(actionAttempt, timeout) {
    super(
      `Timed out waiting for action action attempt after ${timeout}ms`,
      actionAttempt
    );
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
var isSuccessfulActionAttempt = (actionAttempt) => actionAttempt.status === "success";
var isFailedActionAttempt = (actionAttempt) => actionAttempt.status === "error";

// src/lib/seam/connect/routes/client-sessions.ts
var SeamHttpClientSessions = class _SeamHttpClientSessions {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = _SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpClientSessions.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/client_sessions/create",
      method: "post",
      data: body
    });
    return data.client_session;
  }
  async delete(body) {
    await this.client.request({
      url: "/client_sessions/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/client_sessions/get",
      method: "post",
      data: body
    });
    return data.client_session;
  }
  async getOrCreate(body) {
    const { data } = await this.client.request({
      url: "/client_sessions/get_or_create",
      method: "post",
      data: body
    });
    return data.client_session;
  }
  async grantAccess(body) {
    const { data } = await this.client.request({
      url: "/client_sessions/grant_access",
      method: "post",
      data: body
    });
    return data.client_session;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/client_sessions/list",
      method: "post",
      data: body
    });
    return data.client_sessions;
  }
  async revoke(body) {
    await this.client.request({
      url: "/client_sessions/revoke",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/access-codes-unmanaged.ts
var SeamHttpAccessCodesUnmanaged = class _SeamHttpAccessCodesUnmanaged {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  async convertToManaged(body) {
    await this.client.request({
      url: "/access_codes/unmanaged/convert_to_managed",
      method: "post",
      data: body
    });
  }
  async delete(body) {
    await this.client.request({
      url: "/access_codes/unmanaged/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request(
      {
        url: "/access_codes/unmanaged/get",
        method: "post",
        data: body
      }
    );
    return data.access_code;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/access_codes/unmanaged/list",
      method: "post",
      data: body
    });
    return data.access_codes;
  }
  async update(body) {
    await this.client.request({
      url: "/access_codes/unmanaged/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/access-codes.ts
var SeamHttpAccessCodes = class _SeamHttpAccessCodes {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodes.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  get unmanaged() {
    return SeamHttpAccessCodesUnmanaged.fromClient(this.client, this.defaults);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/access_codes/create",
      method: "post",
      data: body
    });
    return data.access_code;
  }
  async createMultiple(body) {
    const { data } = await this.client.request({
      url: "/access_codes/create_multiple",
      method: "post",
      data: body
    });
    return data.access_codes;
  }
  async delete(body) {
    await this.client.request({
      url: "/access_codes/delete",
      method: "post",
      data: body
    });
  }
  async generateCode(body) {
    const { data } = await this.client.request(
      {
        url: "/access_codes/generate_code",
        method: "post",
        data: body
      }
    );
    return data.generated_code;
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/access_codes/get",
      method: "post",
      data: body
    });
    return data.access_code;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/access_codes/list",
      method: "post",
      data: body
    });
    return data.access_codes;
  }
  async pullBackupAccessCode(body) {
    const { data } = await this.client.request({
      url: "/access_codes/pull_backup_access_code",
      method: "post",
      data: body
    });
    return data.backup_access_code;
  }
  async update(body) {
    await this.client.request({
      url: "/access_codes/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/acs-access-groups.ts
var SeamHttpAcsAccessGroups = class _SeamHttpAcsAccessGroups {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsAccessGroups.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  async addUser(body) {
    await this.client.request({
      url: "/acs/access_groups/add_user",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/acs/access_groups/get",
      method: "post",
      data: body
    });
    return data.acs_access_group;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/access_groups/list",
      method: "post",
      data: body
    });
    return data.acs_access_groups;
  }
  async listUsers(body) {
    const { data } = await this.client.request({
      url: "/acs/access_groups/list_users",
      method: "post",
      data: body
    });
    return data.acs_users;
  }
  async removeUser(body) {
    await this.client.request({
      url: "/acs/access_groups/remove_user",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/acs-credential-pools.ts
var SeamHttpAcsCredentialPools = class _SeamHttpAcsCredentialPools {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialPools.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/credential_pools/list",
      method: "post",
      data: body
    });
    return data.acs_credential_pools;
  }
};

// src/lib/seam/connect/routes/acs-credential-provisioning-automations.ts
var SeamHttpAcsCredentialProvisioningAutomations = class _SeamHttpAcsCredentialProvisioningAutomations {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialProvisioningAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  async launch(body) {
    const { data } = await this.client.request(
      {
        url: "/acs/credential_provisioning_automations/launch",
        method: "post",
        data: body
      }
    );
    return data.acs_credential_provisioning_automation;
  }
};

// src/lib/seam/connect/routes/acs-credentials.ts
var SeamHttpAcsCredentials = class _SeamHttpAcsCredentials {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentials.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  async assign(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/assign",
      method: "post",
      data: body
    });
    return data.acs_credential;
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/create",
      method: "post",
      data: body
    });
    return data.acs_credential;
  }
  async delete(body) {
    await this.client.request({
      url: "/acs/credentials/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/get",
      method: "post",
      data: body
    });
    return data.acs_credential;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/list",
      method: "post",
      data: body
    });
    return data.acs_credentials;
  }
  async unassign(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/unassign",
      method: "post",
      data: body
    });
    return data.acs_credential;
  }
  async update(body) {
    const { data } = await this.client.request({
      url: "/acs/credentials/update",
      method: "post",
      data: body
    });
    return data.acs_credential;
  }
};

// src/lib/seam/connect/routes/acs-entrances.ts
var SeamHttpAcsEntrances = class _SeamHttpAcsEntrances {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsEntrances.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/acs/entrances/get",
      method: "post",
      data: body
    });
    return data.acs_entrance;
  }
  async grantAccess(body) {
    await this.client.request({
      url: "/acs/entrances/grant_access",
      method: "post",
      data: body
    });
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/entrances/list",
      method: "post",
      data: body
    });
    return data.acs_entrances;
  }
};

// src/lib/seam/connect/routes/acs-systems.ts
var SeamHttpAcsSystems = class _SeamHttpAcsSystems {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsSystems.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/acs/systems/get",
      method: "post",
      data: body
    });
    return data.acs_system;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/systems/list",
      method: "post",
      data: body
    });
    return data.acs_systems;
  }
};

// src/lib/seam/connect/routes/acs-users.ts
var SeamHttpAcsUsers = class _SeamHttpAcsUsers {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsUsers.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  async addToAccessGroup(body) {
    await this.client.request({
      url: "/acs/users/add_to_access_group",
      method: "post",
      data: body
    });
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/acs/users/create",
      method: "post",
      data: body
    });
    return data.acs_user;
  }
  async delete(body) {
    await this.client.request({
      url: "/acs/users/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/acs/users/get",
      method: "post",
      data: body
    });
    return data.acs_user;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/acs/users/list",
      method: "post",
      data: body
    });
    return data.acs_users;
  }
  async listAccessibleEntrances(body) {
    const { data } = await this.client.request({
      url: "/acs/users/list_accessible_entrances",
      method: "post",
      data: body
    });
    return data.acs_entrances;
  }
  async removeFromAccessGroup(body) {
    await this.client.request({
      url: "/acs/users/remove_from_access_group",
      method: "post",
      data: body
    });
  }
  async suspend(body) {
    await this.client.request({
      url: "/acs/users/suspend",
      method: "post",
      data: body
    });
  }
  async unsuspend(body) {
    await this.client.request({
      url: "/acs/users/unsuspend",
      method: "post",
      data: body
    });
  }
  async update(body) {
    await this.client.request({
      url: "/acs/users/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/acs.ts
var SeamHttpAcs = class _SeamHttpAcs {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcs.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  get accessGroups() {
    return SeamHttpAcsAccessGroups.fromClient(this.client, this.defaults);
  }
  get credentialPools() {
    return SeamHttpAcsCredentialPools.fromClient(this.client, this.defaults);
  }
  get credentialProvisioningAutomations() {
    return SeamHttpAcsCredentialProvisioningAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  get credentials() {
    return SeamHttpAcsCredentials.fromClient(this.client, this.defaults);
  }
  get entrances() {
    return SeamHttpAcsEntrances.fromClient(this.client, this.defaults);
  }
  get systems() {
    return SeamHttpAcsSystems.fromClient(this.client, this.defaults);
  }
  get users() {
    return SeamHttpAcsUsers.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/action-attempts.ts
var SeamHttpActionAttempts = class _SeamHttpActionAttempts {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpActionAttempts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  async get(body, options = {}) {
    const { data } = await this.client.request({
      url: "/action_attempts/get",
      method: "post",
      data: body
    });
    const waitForActionAttempt = options.waitForActionAttempt ?? this.defaults.waitForActionAttempt;
    if (waitForActionAttempt !== false) {
      return await resolveActionAttempt(
        data.action_attempt,
        _SeamHttpActionAttempts.fromClient(this.client, {
          ...this.defaults,
          waitForActionAttempt: false
        }),
        typeof waitForActionAttempt === "boolean" ? {} : waitForActionAttempt
      );
    }
    return data.action_attempt;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/action_attempts/list",
      method: "post",
      data: body
    });
    return data.action_attempts;
  }
};

// src/lib/seam/connect/routes/connect-webviews.ts
var SeamHttpConnectWebviews = class _SeamHttpConnectWebviews {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectWebviews.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/connect_webviews/create",
      method: "post",
      data: body
    });
    return data.connect_webview;
  }
  async delete(body) {
    await this.client.request({
      url: "/connect_webviews/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/connect_webviews/get",
      method: "post",
      data: body
    });
    return data.connect_webview;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/connect_webviews/list",
      method: "post",
      data: body
    });
    return data.connect_webviews;
  }
  async view(params) {
    await this.client.request({
      url: "/connect_webviews/view",
      method: "get",
      params
    });
  }
};

// src/lib/seam/connect/routes/connected-accounts.ts
var SeamHttpConnectedAccounts = class _SeamHttpConnectedAccounts {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectedAccounts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  async delete(body) {
    await this.client.request({
      url: "/connected_accounts/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/connected_accounts/get",
      method: "post",
      data: body
    });
    return data.connected_account;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/connected_accounts/list",
      method: "post",
      data: body
    });
    return data.connected_accounts;
  }
  async update(body) {
    const { data } = await this.client.request(
      {
        url: "/connected_accounts/update",
        method: "post",
        data: body
      }
    );
    return data.connected_account;
  }
};

// src/lib/seam/connect/routes/devices-unmanaged.ts
var SeamHttpDevicesUnmanaged = class _SeamHttpDevicesUnmanaged {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevicesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/devices/unmanaged/get",
      method: "post",
      data: body
    });
    return data.device;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/devices/unmanaged/list",
      method: "post",
      data: body
    });
    return data.devices;
  }
  async update(body) {
    await this.client.request({
      url: "/devices/unmanaged/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/devices.ts
var SeamHttpDevices = class _SeamHttpDevices {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevices.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  get unmanaged() {
    return SeamHttpDevicesUnmanaged.fromClient(this.client, this.defaults);
  }
  async delete(body) {
    await this.client.request({
      url: "/devices/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/devices/get",
      method: "post",
      data: body
    });
    return data.device;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/devices/list",
      method: "post",
      data: body
    });
    return data.devices;
  }
  async listDeviceProviders(body) {
    const { data } = await this.client.request({
      url: "/devices/list_device_providers",
      method: "post",
      data: body
    });
    return data.device_providers;
  }
  async update(body) {
    await this.client.request({
      url: "/devices/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/events.ts
var SeamHttpEvents = class _SeamHttpEvents {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpEvents.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/events/get",
      method: "post",
      data: body
    });
    return data.event;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/events/list",
      method: "post",
      data: body
    });
    return data.events;
  }
};

// src/lib/seam/connect/routes/locks.ts
var SeamHttpLocks = class _SeamHttpLocks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpLocks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/locks/get",
      method: "post",
      data: body
    });
    return data.device;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/locks/list",
      method: "post",
      data: body
    });
    return data.devices;
  }
  async lockDoor(body, options = {}) {
    const { data } = await this.client.request({
      url: "/locks/lock_door",
      method: "post",
      data: body
    });
    const waitForActionAttempt = options.waitForActionAttempt ?? this.defaults.waitForActionAttempt;
    if (waitForActionAttempt !== false) {
      return await resolveActionAttempt(
        data.action_attempt,
        SeamHttpActionAttempts.fromClient(this.client, {
          ...this.defaults,
          waitForActionAttempt: false
        }),
        typeof waitForActionAttempt === "boolean" ? {} : waitForActionAttempt
      );
    }
    return data.action_attempt;
  }
  async unlockDoor(body, options = {}) {
    const { data } = await this.client.request({
      url: "/locks/unlock_door",
      method: "post",
      data: body
    });
    const waitForActionAttempt = options.waitForActionAttempt ?? this.defaults.waitForActionAttempt;
    if (waitForActionAttempt !== false) {
      return await resolveActionAttempt(
        data.action_attempt,
        SeamHttpActionAttempts.fromClient(this.client, {
          ...this.defaults,
          waitForActionAttempt: false
        }),
        typeof waitForActionAttempt === "boolean" ? {} : waitForActionAttempt
      );
    }
    return data.action_attempt;
  }
};

// src/lib/seam/connect/routes/networks.ts
var SeamHttpNetworks = class _SeamHttpNetworks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNetworks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/networks/get",
      method: "post",
      data: body
    });
    return data.network;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/networks/list",
      method: "post",
      data: body
    });
    return data.networks;
  }
};

// src/lib/seam/connect/routes/noise-sensors-noise-thresholds.ts
var SeamHttpNoiseSensorsNoiseThresholds = class _SeamHttpNoiseSensorsNoiseThresholds {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensorsNoiseThresholds.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/noise_sensors/noise_thresholds/create",
      method: "post",
      data: body
    });
    return data.noise_threshold;
  }
  async delete(body) {
    await this.client.request({
      url: "/noise_sensors/noise_thresholds/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/noise_sensors/noise_thresholds/get",
      method: "post",
      data: body
    });
    return data.noise_threshold;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/noise_sensors/noise_thresholds/list",
      method: "post",
      data: body
    });
    return data.noise_thresholds;
  }
  async update(body) {
    await this.client.request({
      url: "/noise_sensors/noise_thresholds/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors.ts
var SeamHttpNoiseSensors = class _SeamHttpNoiseSensors {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensors.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  get noiseThresholds() {
    return SeamHttpNoiseSensorsNoiseThresholds.fromClient(
      this.client,
      this.defaults
    );
  }
};

// src/lib/seam/connect/routes/phones.ts
var SeamHttpPhones = class _SeamHttpPhones {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpPhones.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/phones/list",
      method: "post",
      data: body
    });
    return data.phones;
  }
};

// src/lib/seam/connect/routes/thermostats-climate-setting-schedules.ts
var SeamHttpThermostatsClimateSettingSchedules = class _SeamHttpThermostatsClimateSettingSchedules {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostatsClimateSettingSchedules.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request(
      {
        url: "/thermostats/climate_setting_schedules/create",
        method: "post",
        data: body
      }
    );
    return data.climate_setting_schedule;
  }
  async delete(body) {
    await this.client.request(
      {
        url: "/thermostats/climate_setting_schedules/delete",
        method: "post",
        data: body
      }
    );
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/thermostats/climate_setting_schedules/get",
      method: "post",
      data: body
    });
    return data.climate_setting_schedule;
  }
  async list(body) {
    const { data } = await this.client.request(
      {
        url: "/thermostats/climate_setting_schedules/list",
        method: "post",
        data: body
      }
    );
    return data.climate_setting_schedules;
  }
  async update(body) {
    await this.client.request(
      {
        url: "/thermostats/climate_setting_schedules/update",
        method: "post",
        data: body
      }
    );
  }
};

// src/lib/seam/connect/routes/thermostats.ts
var SeamHttpThermostats = class _SeamHttpThermostats {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostats.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  get climateSettingSchedules() {
    return SeamHttpThermostatsClimateSettingSchedules.fromClient(
      this.client,
      this.defaults
    );
  }
  async cool(body) {
    await this.client.request({
      url: "/thermostats/cool",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/thermostats/get",
      method: "post",
      data: body
    });
    return data.thermostat;
  }
  async heat(body) {
    await this.client.request({
      url: "/thermostats/heat",
      method: "post",
      data: body
    });
  }
  async heatCool(body) {
    await this.client.request({
      url: "/thermostats/heat_cool",
      method: "post",
      data: body
    });
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/thermostats/list",
      method: "post",
      data: body
    });
    return data.thermostats;
  }
  async off(body) {
    await this.client.request({
      url: "/thermostats/off",
      method: "post",
      data: body
    });
  }
  async setFanMode(body) {
    await this.client.request({
      url: "/thermostats/set_fan_mode",
      method: "post",
      data: body
    });
  }
  async update(body) {
    await this.client.request({
      url: "/thermostats/update",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/user-identities-enrollment-automations.ts
var SeamHttpUserIdentitiesEnrollmentAutomations = class _SeamHttpUserIdentitiesEnrollmentAutomations {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentitiesEnrollmentAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  async get(body) {
    const { data } = await this.client.request(
      {
        url: "/user_identities/enrollment_automations/get",
        method: "post",
        data: body
      }
    );
    return data.enrollment_automation;
  }
  async launch(body) {
    const { data } = await this.client.request(
      {
        url: "/user_identities/enrollment_automations/launch",
        method: "post",
        data: body
      }
    );
    return data.enrollment_automation;
  }
  async list(body) {
    const { data } = await this.client.request(
      {
        url: "/user_identities/enrollment_automations/list",
        method: "post",
        data: body
      }
    );
    return data.enrollment_automations;
  }
};

// src/lib/seam/connect/routes/user-identities.ts
var SeamHttpUserIdentities = class _SeamHttpUserIdentities {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentities.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  get enrollmentAutomations() {
    return SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  async addAcsUser(body) {
    await this.client.request({
      url: "/user_identities/add_acs_user",
      method: "post",
      data: body
    });
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/user_identities/create",
      method: "post",
      data: body
    });
    return data.user_identity;
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/user_identities/get",
      method: "post",
      data: body
    });
    return data.user_identity;
  }
  async grantAccessToDevice(body) {
    await this.client.request({
      url: "/user_identities/grant_access_to_device",
      method: "post",
      data: body
    });
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/user_identities/list",
      method: "post",
      data: body
    });
    return data.user_identities;
  }
  async listAccessibleDevices(body) {
    const { data } = await this.client.request({
      url: "/user_identities/list_accessible_devices",
      method: "post",
      data: body
    });
    return data.accessible_devices;
  }
  async listAcsSystems(body) {
    const { data } = await this.client.request({
      url: "/user_identities/list_acs_systems",
      method: "post",
      data: body
    });
    return data.acs_systems;
  }
  async listAcsUsers(body) {
    const { data } = await this.client.request({
      url: "/user_identities/list_acs_users",
      method: "post",
      data: body
    });
    return data.acs_users;
  }
  async removeAcsUser(body) {
    await this.client.request({
      url: "/user_identities/remove_acs_user",
      method: "post",
      data: body
    });
  }
  async revokeAccessToDevice(body) {
    await this.client.request({
      url: "/user_identities/revoke_access_to_device",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/routes/webhooks.ts
var SeamHttpWebhooks = class _SeamHttpWebhooks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWebhooks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/webhooks/create",
      method: "post",
      data: body
    });
    return data.webhook;
  }
  async delete(body) {
    await this.client.request({
      url: "/webhooks/delete",
      method: "post",
      data: body
    });
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/webhooks/get",
      method: "post",
      data: body
    });
    return data.webhook;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/webhooks/list",
      method: "post",
      data: body
    });
    return data.webhooks;
  }
};

// src/lib/seam/connect/routes/workspaces.ts
var SeamHttpWorkspaces = class _SeamHttpWorkspaces {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWorkspaces.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  async create(body) {
    const { data } = await this.client.request({
      url: "/workspaces/create",
      method: "post",
      data: body
    });
    return data.workspace;
  }
  async get(body) {
    const { data } = await this.client.request({
      url: "/workspaces/get",
      method: "post",
      data: body
    });
    return data.workspace;
  }
  async list(body) {
    const { data } = await this.client.request({
      url: "/workspaces/list",
      method: "post",
      data: body
    });
    return data.workspaces;
  }
  async resetSandbox(body) {
    await this.client.request({
      url: "/workspaces/reset_sandbox",
      method: "post",
      data: body
    });
  }
};

// src/lib/seam/connect/seam-http.ts
var SeamHttp = class _SeamHttp {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttp(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttp.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  get accessCodes() {
    return SeamHttpAccessCodes.fromClient(this.client, this.defaults);
  }
  get acs() {
    return SeamHttpAcs.fromClient(this.client, this.defaults);
  }
  get actionAttempts() {
    return SeamHttpActionAttempts.fromClient(this.client, this.defaults);
  }
  get clientSessions() {
    return SeamHttpClientSessions.fromClient(this.client, this.defaults);
  }
  get connectedAccounts() {
    return SeamHttpConnectedAccounts.fromClient(this.client, this.defaults);
  }
  get connectWebviews() {
    return SeamHttpConnectWebviews.fromClient(this.client, this.defaults);
  }
  get devices() {
    return SeamHttpDevices.fromClient(this.client, this.defaults);
  }
  get events() {
    return SeamHttpEvents.fromClient(this.client, this.defaults);
  }
  get locks() {
    return SeamHttpLocks.fromClient(this.client, this.defaults);
  }
  get networks() {
    return SeamHttpNetworks.fromClient(this.client, this.defaults);
  }
  get noiseSensors() {
    return SeamHttpNoiseSensors.fromClient(this.client, this.defaults);
  }
  get phones() {
    return SeamHttpPhones.fromClient(this.client, this.defaults);
  }
  get thermostats() {
    return SeamHttpThermostats.fromClient(this.client, this.defaults);
  }
  get userIdentities() {
    return SeamHttpUserIdentities.fromClient(this.client, this.defaults);
  }
  get webhooks() {
    return SeamHttpWebhooks.fromClient(this.client, this.defaults);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/seam-http-multi-workspace.ts
var SeamHttpMultiWorkspace = class _SeamHttpMultiWorkspace {
  constructor(options) {
    const opts = parseOptions(options);
    this.client = "client" in opts ? opts.client : createClient(opts);
    this.defaults = limitToSeamHttpRequestOptions(opts);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpMultiWorkspaceOptionsWithClient(constructorOptions)) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError("Missing client");
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  static fromConsoleSessionToken(consoleSessionToken, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken };
    if (!isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(
      constructorOptions
    )) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError(
        "Missing consoleSessionToken"
      );
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, options = {}) {
    const constructorOptions = { ...options, personalAccessToken };
    if (!isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(
      constructorOptions
    )) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError(
        "Missing personalAccessToken"
      );
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};

exports.SeamActionAttemptError = SeamActionAttemptError;
exports.SeamActionAttemptFailedError = SeamActionAttemptFailedError;
exports.SeamActionAttemptTimeoutError = SeamActionAttemptTimeoutError;
exports.SeamHttp = SeamHttp;
exports.SeamHttpAccessCodes = SeamHttpAccessCodes;
exports.SeamHttpAccessCodesUnmanaged = SeamHttpAccessCodesUnmanaged;
exports.SeamHttpAcs = SeamHttpAcs;
exports.SeamHttpAcsAccessGroups = SeamHttpAcsAccessGroups;
exports.SeamHttpAcsCredentialPools = SeamHttpAcsCredentialPools;
exports.SeamHttpAcsCredentialProvisioningAutomations = SeamHttpAcsCredentialProvisioningAutomations;
exports.SeamHttpAcsCredentials = SeamHttpAcsCredentials;
exports.SeamHttpAcsEntrances = SeamHttpAcsEntrances;
exports.SeamHttpAcsSystems = SeamHttpAcsSystems;
exports.SeamHttpAcsUsers = SeamHttpAcsUsers;
exports.SeamHttpActionAttempts = SeamHttpActionAttempts;
exports.SeamHttpApiError = SeamHttpApiError;
exports.SeamHttpClientSessions = SeamHttpClientSessions;
exports.SeamHttpConnectWebviews = SeamHttpConnectWebviews;
exports.SeamHttpConnectedAccounts = SeamHttpConnectedAccounts;
exports.SeamHttpDevices = SeamHttpDevices;
exports.SeamHttpDevicesUnmanaged = SeamHttpDevicesUnmanaged;
exports.SeamHttpEvents = SeamHttpEvents;
exports.SeamHttpInvalidInputError = SeamHttpInvalidInputError;
exports.SeamHttpInvalidOptionsError = SeamHttpInvalidOptionsError;
exports.SeamHttpInvalidTokenError = SeamHttpInvalidTokenError;
exports.SeamHttpLocks = SeamHttpLocks;
exports.SeamHttpMultiWorkspace = SeamHttpMultiWorkspace;
exports.SeamHttpMultiWorkspaceInvalidOptionsError = SeamHttpMultiWorkspaceInvalidOptionsError;
exports.SeamHttpNetworks = SeamHttpNetworks;
exports.SeamHttpNoiseSensors = SeamHttpNoiseSensors;
exports.SeamHttpNoiseSensorsNoiseThresholds = SeamHttpNoiseSensorsNoiseThresholds;
exports.SeamHttpPhones = SeamHttpPhones;
exports.SeamHttpThermostats = SeamHttpThermostats;
exports.SeamHttpThermostatsClimateSettingSchedules = SeamHttpThermostatsClimateSettingSchedules;
exports.SeamHttpUnauthorizedError = SeamHttpUnauthorizedError;
exports.SeamHttpUserIdentities = SeamHttpUserIdentities;
exports.SeamHttpUserIdentitiesEnrollmentAutomations = SeamHttpUserIdentitiesEnrollmentAutomations;
exports.SeamHttpWebhooks = SeamHttpWebhooks;
exports.SeamHttpWorkspaces = SeamHttpWorkspaces;
exports.errorInterceptor = errorInterceptor;
exports.getOpenapiSchema = getOpenapiSchema;
exports.isApiKey = isApiKey;
exports.isClientSessionToken = isClientSessionToken;
exports.isConsoleSessionToken = isConsoleSessionToken;
exports.isPersonalAccessToken = isPersonalAccessToken;
exports.isPublishableKey = isPublishableKey;
exports.isSeamActionAttemptError = isSeamActionAttemptError;
exports.isSeamActionAttemptFailedError = isSeamActionAttemptFailedError;
exports.isSeamActionAttemptTimeoutError = isSeamActionAttemptTimeoutError;
exports.isSeamHttpApiError = isSeamHttpApiError;
exports.isSeamHttpInvalidInputError = isSeamHttpInvalidInputError;
exports.isSeamHttpMultiWorkspaceOptionsWithClient = isSeamHttpMultiWorkspaceOptionsWithClient;
exports.isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken = isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken;
exports.isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken = isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
exports.isSeamHttpOptionsWithApiKey = isSeamHttpOptionsWithApiKey;
exports.isSeamHttpOptionsWithClient = isSeamHttpOptionsWithClient;
exports.isSeamHttpOptionsWithClientSessionToken = isSeamHttpOptionsWithClientSessionToken;
exports.isSeamHttpOptionsWithConsoleSessionToken = isSeamHttpOptionsWithConsoleSessionToken;
exports.isSeamHttpOptionsWithPersonalAccessToken = isSeamHttpOptionsWithPersonalAccessToken;
exports.isSeamHttpUnauthorizedError = isSeamHttpUnauthorizedError;
Object.keys(urlSearchParamsSerializer).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return urlSearchParamsSerializer[k]; }
  });
});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=connect.cjs.map